[{"header":"Основные (Fundamental)","links":[{"title":"Контейнер свойств (property container)","data":{"path":"App\\Http\\Controllers\\FundamentalPatterns@PropertyContainer","description":"обычно нужен для того, что бы расширить свойства класса путём динамического добавления\r\n\r\nчто бы не надо было лезть в класс и постоянно писать какие то дополнительные переменные\r\n\r\n<a href=\"https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BD%D1%82%D0%B5%D0%B9%D0%BD%D0%B5%D1%80_%D1%81%D0%B2%D0%BE%D0%B9%D1%81%D1%82%D0%B2_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)\" target=\"_blank\">Ссыль</a>\r\n","code":"//интерфейс нужен для того что бы обозначить правила классов, которые наследуются от него, какие методы необходимо реализовать \r\ninterface PropertyInterface {\r\n\tfunction AddProperty($propertyName, $value); //создать свойство с данными\r\n\tfunction DeleteProperty($propertyName); //удалить свойство \r\n\tfunction GetProperty($propertyName); //получить данные из свойства \r\n\tfunction SetProperty($propertyName, $value); //обновить данные в свойстве \r\n\t\r\n}\r\n\r\n//класс контейнер наследуется от интерфейса для реализации логики по правилам интерфейса\r\nclass PropertyContainer extends PropertyInterface {\r\n\tprivate $propertyContainer = [];\r\n\t\r\n\tpublic function AddProperty($propertyName, $value) {\r\n\t\t$this->propertyContainer[$propertyName] = $value;\r\n\t}\r\n\t\r\n\tpublic function DeleteProperty($propertyName) {\r\n\t\tunset(propertyContainer[$propertyName]);\r\n\t}\r\n\t\r\n\tpublic function GetProperty($propertyName) {\r\n\t\treturn $this->propertyContainer[$propertyName] ?? null;\r\n\t}\r\n\t\r\n\tpublic function SetProperty($propertyName, $value) {\r\n\t\tif(!isset($this->propertyContainer[$propertyName])) {\r\n\t\t\tthrow new Exception(\"Property [{$propertyName}] is not found\");\r\n\t\t}\r\n\t\t$this->propertyContainer[$propertyName] = $value;\r\n\t}\r\n}\r\n\r\n\r\n//допустим есть класс \r\n//в классе всегда лучше оставлять линк на то, какой ты шаблон проектирования использовал\r\nclass BlogPost extends PropertyContainer {\r\n\t//used pattern https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BD%D1%82%D0%B5%D0%B9%D0%BD%D0%B5%D1%80_%D1%81%D0%B2%D0%BE%D0%B9%D1%81%D1%82%D0%B2_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)\r\n\t//some...\r\n\t//functions bla bla \r\n}\r\n\r\n//применение:\r\n$blog = new BlogPost();\r\n$blog->AddProperty('name', 'Ras');\r\n$name = $blog->GetProperty('name');\r\n$blog->SetProperty('name', 'saR');\r\n$blog->DeleteProperty('name');"}},{"title":"Делегирование (Delegation)","data":{"code":"//ну для начала реализуем интерфейс, по которому нужно будет реализовывать наследуюемые классы\r\ninterface MessengerInterface {\r\n\t//установить отправителя\r\n\tpublic function setSender($value): MessengerInterface;\r\n\r\n\t//установить получателя\r\n\tpublic function setRecipient($value): MessengerInterface;\r\n\r\n\t//установить сообщение\r\n\tpublic function setMessage($value): MessengerInterface;\r\n\r\n\t//отправить сообщение\r\n\tpublic function send():bool; \r\n}\r\n\r\n//Абстрактный класс, который реализовывает базовые методы интерфейса\r\n//последующие классы наследуются от абстрактного класса, для дальнейшей реализации\r\nabstract class AbstractMessenger implements MessengerInterface {\r\n\tprotected $sender; //отправитель\r\n\r\n\tprotected $recipient; //получатель\r\n\r\n\tprotected $message; //сообщение \r\n\r\n\t//установить отправителя\r\n\tpublic function setSender($value) : MessengerInterface\r\n\t{\r\n\t\t$this->sender = $value;\r\n\t\treturn $this;\r\n\t}\r\n\r\n\t//установить получателя\r\n\tpublic function setRecipient($value): MessengerInterface\r\n\t{\r\n\t\t$this->recipient = $value;\r\n\t\treturn $this;\r\n\t}\r\n\r\n\tpublic function setMessage($value): MessengerInterface\r\n\t{\r\n\t\t$this->message = $value;\r\n\t\treturn $this;\r\n\t}\r\n\r\n\t//отправить сообщение\r\n\tpublic function send(): bool \r\n\t{\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\n//т.к. мы наследуемся от абстрактного класса, то метод send() будет перегружен,\r\n//поэтому, мы отправляем сенд на абстрактный класс через parrent\r\n//\r\nclass EmailMessenger extends AbstractMessenger {\r\n\t//тут много кода по реализации отправки по email\r\n\tpublic function send(): bool \r\n\t{\r\n\t\t//тут код отправки\r\n\t\techo 'Send by Email<br>';\r\n\t\treturn parent::send(); //отправляем из абстрактного класса\r\n\t}\r\n}\r\n\r\nclass SmsMessenger extends AbstractMessenger {\r\n\t//тут много кода реализации отправки по СМС\r\n\tpublic function send(): bool \r\n\t{\r\n\t\t//тут код отправки\r\n\t\techo 'Send by SMS<br>';\r\n\t\treturn parent::send(); //отправляем из абстрактного класса\r\n\t}\r\n}\r\n\r\n//сам класс который будет делегировать \r\nclass AppMessenger implements MessengerInterface {\r\n\t\r\n\t//приватное свойство messenger, это тот, на кого мы будем делегировать работу (экземпляр класса)\r\n\tprivate $messenger; \r\n\r\n\tpublic function __construct(){\r\n\t\t//по дефолту вызывем метод toEmail где у нас создаётся класс EmailMessenger и присваивается в messenger переменную\r\n\t\t//это нужно чтоб ничто не сломалось\r\n\t\t$this->toEmail(); \r\n\t}\r\n\r\n\tstatic public function getDescription() {\r\n\r\n\t}\r\n\r\n\t//если по email, то вернём экземпляр класса \r\n\t//EmailMessenger и ещё присвоим его в переменную messenger\r\n\tpublic function toEmail(){ \r\n\t\t$this->messenger = new EmailMessenger();\r\n\t\treturn $this;\r\n\t}\r\n\r\n\r\n\t//если по sms, то вернём экземпляр класса\r\n\t//SmsMessenger и ещё присвоим его в переменную messenger\r\n\tpublic function toSMS(){\r\n\t\t//т.к. у нас изначально toEmail, то тут мы просто перезапишем в messenger новый экземпляр класса SmsMessenger\r\n\t\t$this->messenger = new SmsMessenger();\r\n\t\treturn $this;\r\n\t}\r\n\r\n\t//т.к. у нас данный класс так же наследуется от интерфейса, то нам необходимо реализовать его методы\r\n\tpublic function setSender($value): MessengerInterface { //обязательно возвращаемый у нас будет MessengerInterface\r\n\t\t$this->messenger->setSender($value); //но тут мы будем делегировать методы в тот класс, который породили в messenger\r\n\t\treturn $this->messenger;\r\n\t}\r\n\r\n\t//т.к. у нас данный класс так же наследуется от интерфейса, то нам необходимо реализовать его методы\r\n\tpublic function setRecipient($value): MessengerInterface { //обязательно возвращаемый у нас будет MessengerInterface\r\n\t\t$this->messenger->setRecipient($value); //но тут мы будем делегировать методы в тот класс, который породили в messenger\r\n\t\treturn $this->messenger;\r\n\t}\r\n\t\r\n\t//т.к. у нас данный класс так же наследуется от интерфейса, то нам необходимо реализовать его методы\r\n\tpublic function setMessage($value): MessengerInterface {\r\n\t\t$this->messenger->setMessage($value); //но тут мы будем делегировать методы в тот класс, который породили в messenger\r\n\t\treturn $this->messenger;\r\n\t}\r\n\r\n\r\n\t//т.к. у нас данный класс так же наследуется от интерфейса, то нам необходимо реализовать его методы\r\n\tpublic function send(): bool {\r\n\t\treturn $this->messenger->send(); //но тут мы будем делегировать методы в тот класс, который породили в messenger\r\n\t}\r\n\r\n}\r\n\r\n//применение:\r\nfunction Delegation() {\r\n\t$name = 'Делегирование (Delegation)';\r\n\t$description = AppMessenger::getDescription();\r\n\r\n\t$item = new AppMessenger();\r\n\r\n\t//ну по дефолту у нас email, поэтому так и оставляем\r\n\t$item->setSender('sender@example.com')\r\n\t\t->setRecipient('recipitne@example.com')\r\n\t\t->setMessage('Hello world from email')\r\n\t\t->send();\r\n\r\n\t//но если у нас sms то в начале устанавливаем toSms\r\n\t$item->toSms()\r\n\t\t->setSender('1111111111')\r\n\t\t->setRecipient('2222222222')\r\n\t\t->setMessage('Hello world from SMS')\r\n\t\t->send();\r\n\r\n}\r\nDelegation();","description":" Обычно нужен для того, чтоб передать работу другим связанным классам (своими словами)\r\n - Основной шаблон проектирования, в котором объект внешне выражает некоторое поведение, но в реальности передаёт ответственность за выполнение этого поведения связанному объекту.\r\n- Шаблон делегирования является фундаментальной абстракцией, на основе которой реализованы другие шаблоны - композиция (так называемая агрегация), и примеси (mixins) а так же аспекты (aspects).\r\n<a href=\"https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%B4%D0%B5%D0%BB%D0%B5%D0%B3%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F\">Линк</a>","path":"App\\Http\\Controllers\\FundamentalPatternsController@Delegation"}},{"title":"Канал событий (event channel)","data":{"code":"!","description":"Есть событие (event) в классе, а есть получатель события (там где мы хотим отрабатывать что то, оповещать). Получатель после получения события выполняет свой код допустим, вот посредник между ними это Event Channel который является связующим звеном.   (Своими словами)\r\n\r\nв общем есть:\r\n- Publisher : издатель, который создаёт контент какой либо\r\n- Subscriber: подписчик на контент\r\n- Event Channel: тот который следит за событиями Publisher и в случае совпадения с группой подписки Subscriber, уведомляет его (посылает событие)\r\n\r\nА это с видоса:\r\nКанал событий (event channel) - фундаментальный шаблон проектирования, используется для\r\nсоздания канала связи и коммуникации через него посредством событий.\r\n\r\nЭтот канал обеспечивает возможность разным издателям публиковать\r\nсобытия и подписчикам, подписывясь на них, получать уведомления.\r\n\r\n<a href=\"https://ru.wikipedia.org/wiki/%D0%9A%D0%B0%D0%BD%D0%B0%D0%BB_%D1%81%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D0%B9_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)\">Ссылка</a>","path":"App\\Http\\Controllers\\FundamentalPatternsController@EventChannel"}}]},{"header":"Порождающие шаблоны (Creational)","links":[]},{"header":"Структурные шаблоны (Structural)"},{"header":"Поведенческие шаблоны (Behavioral)"}]