[{"header":"Основные (Fundamental)","links":[{"title":"Контейнер свойств (property container)","data":{"path":"PropertyContainer","description":"<strong>Своими словами:</strong>\r\nобычно нужен для того, что бы расширить свойства класса путём динамического добавления\r\nчто бы не надо было лезть в класс и постоянно писать какие то дополнительные переменные\r\n\r\n<hr>\r\n<strong>Статья с википедиа:</strong>\r\nКонтейнер свойств (англ. property container) — фундаментальный шаблон проектирования, который служит для обеспечения возможности уже построенного и развернутого приложения\r\n\r\n<a href=\"https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BD%D1%82%D0%B5%D0%B9%D0%BD%D0%B5%D1%80_%D1%81%D0%B2%D0%BE%D0%B9%D1%81%D1%82%D0%B2_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)\" target=\"_blank\">Ссылка</a>\r\n","code":"//интерфейс нужен для того что бы обозначить правила классов, которые наследуются от него, какие методы необходимо реализовать \r\ninterface PropertyInterface {\r\n\tfunction AddProperty($propertyName, $value); //создать свойство с данными\r\n\tfunction DeleteProperty($propertyName); //удалить свойство \r\n\tfunction GetProperty($propertyName); //получить данные из свойства \r\n\tfunction SetProperty($propertyName, $value); //обновить данные в свойстве \r\n\t\r\n}\r\n\r\n//класс контейнер наследуется от интерфейса для реализации логики по правилам интерфейса\r\nclass PropertyContainer extends PropertyInterface {\r\n\tprivate $propertyContainer = [];\r\n\t\r\n\tpublic function AddProperty($propertyName, $value) {\r\n\t\t$this->propertyContainer[$propertyName] = $value;\r\n\t}\r\n\t\r\n\tpublic function DeleteProperty($propertyName) {\r\n\t\tunset(propertyContainer[$propertyName]);\r\n\t}\r\n\t\r\n\tpublic function GetProperty($propertyName) {\r\n\t\treturn $this->propertyContainer[$propertyName] ?? null;\r\n\t}\r\n\t\r\n\tpublic function SetProperty($propertyName, $value) {\r\n\t\tif(!isset($this->propertyContainer[$propertyName])) {\r\n\t\t\tthrow new Exception(\"Property [{$propertyName}] is not found\");\r\n\t\t}\r\n\t\t$this->propertyContainer[$propertyName] = $value;\r\n\t}\r\n}\r\n\r\n\r\n//допустим есть класс \r\n//в классе всегда лучше оставлять линк на то, какой ты шаблон проектирования использовал\r\nclass BlogPost extends PropertyContainer {\r\n\t//used pattern https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BD%D1%82%D0%B5%D0%B9%D0%BD%D0%B5%D1%80_%D1%81%D0%B2%D0%BE%D0%B9%D1%81%D1%82%D0%B2_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)\r\n\t//some...\r\n\t//functions bla bla \r\n}\r\n\r\n//применение:\r\n$blog = new BlogPost();\r\n$blog->AddProperty('name', 'Ras');\r\n$name = $blog->GetProperty('name');\r\n$blog->SetProperty('name', 'saR');\r\n$blog->DeleteProperty('name');"}},{"title":"Делегирование (Delegation)","data":{"code":"//ну для начала реализуем интерфейс, по которому нужно будет реализовывать наследуюемые классы\r\ninterface MessengerInterface {\r\n\t//установить отправителя\r\n\tpublic function setSender($value): MessengerInterface;\r\n\r\n\t//установить получателя\r\n\tpublic function setRecipient($value): MessengerInterface;\r\n\r\n\t//установить сообщение\r\n\tpublic function setMessage($value): MessengerInterface;\r\n\r\n\t//отправить сообщение\r\n\tpublic function send():bool; \r\n}\r\n\r\n//Абстрактный класс, который реализовывает базовые методы интерфейса\r\n//последующие классы наследуются от абстрактного класса, для дальнейшей реализации\r\nabstract class AbstractMessenger implements MessengerInterface {\r\n\tprotected $sender; //отправитель\r\n\r\n\tprotected $recipient; //получатель\r\n\r\n\tprotected $message; //сообщение \r\n\r\n\t//установить отправителя\r\n\tpublic function setSender($value) : MessengerInterface\r\n\t{\r\n\t\t$this->sender = $value;\r\n\t\treturn $this;\r\n\t}\r\n\r\n\t//установить получателя\r\n\tpublic function setRecipient($value): MessengerInterface\r\n\t{\r\n\t\t$this->recipient = $value;\r\n\t\treturn $this;\r\n\t}\r\n\r\n\tpublic function setMessage($value): MessengerInterface\r\n\t{\r\n\t\t$this->message = $value;\r\n\t\treturn $this;\r\n\t}\r\n\r\n\t//отправить сообщение\r\n\tpublic function send(): bool \r\n\t{\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\n//т.к. мы наследуемся от абстрактного класса, то метод send() будет перегружен,\r\n//поэтому, мы отправляем сенд на абстрактный класс через parrent\r\n//\r\nclass EmailMessenger extends AbstractMessenger {\r\n\t//тут много кода по реализации отправки по email\r\n\tpublic function send(): bool \r\n\t{\r\n\t\t//тут код отправки\r\n\t\techo 'Send by Email<br>';\r\n\t\treturn parent::send(); //отправляем из абстрактного класса\r\n\t}\r\n}\r\n\r\nclass SmsMessenger extends AbstractMessenger {\r\n\t//тут много кода реализации отправки по СМС\r\n\tpublic function send(): bool \r\n\t{\r\n\t\t//тут код отправки\r\n\t\techo 'Send by SMS<br>';\r\n\t\treturn parent::send(); //отправляем из абстрактного класса\r\n\t}\r\n}\r\n\r\n//сам класс который будет делегировать \r\nclass AppMessenger implements MessengerInterface {\r\n\t\r\n\t//приватное свойство messenger, это тот, на кого мы будем делегировать работу (экземпляр класса)\r\n\tprivate $messenger; \r\n\r\n\tpublic function __construct(){\r\n\t\t//по дефолту вызывем метод toEmail где у нас создаётся класс EmailMessenger и присваивается в messenger переменную\r\n\t\t//это нужно чтоб ничто не сломалось\r\n\t\t$this->toEmail(); \r\n\t}\r\n\r\n\tstatic public function getDescription() {\r\n\r\n\t}\r\n\r\n\t//если по email, то вернём экземпляр класса \r\n\t//EmailMessenger и ещё присвоим его в переменную messenger\r\n\tpublic function toEmail(){ \r\n\t\t$this->messenger = new EmailMessenger();\r\n\t\treturn $this;\r\n\t}\r\n\r\n\r\n\t//если по sms, то вернём экземпляр класса\r\n\t//SmsMessenger и ещё присвоим его в переменную messenger\r\n\tpublic function toSMS(){\r\n\t\t//т.к. у нас изначально toEmail, то тут мы просто перезапишем в messenger новый экземпляр класса SmsMessenger\r\n\t\t$this->messenger = new SmsMessenger();\r\n\t\treturn $this;\r\n\t}\r\n\r\n\t//т.к. у нас данный класс так же наследуется от интерфейса, то нам необходимо реализовать его методы\r\n\tpublic function setSender($value): MessengerInterface { //обязательно возвращаемый у нас будет MessengerInterface\r\n\t\t$this->messenger->setSender($value); //но тут мы будем делегировать методы в тот класс, который породили в messenger\r\n\t\treturn $this->messenger;\r\n\t}\r\n\r\n\t//т.к. у нас данный класс так же наследуется от интерфейса, то нам необходимо реализовать его методы\r\n\tpublic function setRecipient($value): MessengerInterface { //обязательно возвращаемый у нас будет MessengerInterface\r\n\t\t$this->messenger->setRecipient($value); //но тут мы будем делегировать методы в тот класс, который породили в messenger\r\n\t\treturn $this->messenger;\r\n\t}\r\n\t\r\n\t//т.к. у нас данный класс так же наследуется от интерфейса, то нам необходимо реализовать его методы\r\n\tpublic function setMessage($value): MessengerInterface {\r\n\t\t$this->messenger->setMessage($value); //но тут мы будем делегировать методы в тот класс, который породили в messenger\r\n\t\treturn $this->messenger;\r\n\t}\r\n\r\n\r\n\t//т.к. у нас данный класс так же наследуется от интерфейса, то нам необходимо реализовать его методы\r\n\tpublic function send(): bool {\r\n\t\treturn $this->messenger->send(); //но тут мы будем делегировать методы в тот класс, который породили в messenger\r\n\t}\r\n\r\n}\r\n\r\n//применение:\r\nfunction Delegation() {\r\n\t$name = 'Делегирование (Delegation)';\r\n\t$description = AppMessenger::getDescription();\r\n\r\n\t$item = new AppMessenger();\r\n\r\n\t//ну по дефолту у нас email, поэтому так и оставляем\r\n\t$item->setSender('sender@example.com')\r\n\t\t->setRecipient('recipitne@example.com')\r\n\t\t->setMessage('Hello world from email')\r\n\t\t->send();\r\n\r\n\t//но если у нас sms то в начале устанавливаем toSms\r\n\t$item->toSms()\r\n\t\t->setSender('1111111111')\r\n\t\t->setRecipient('2222222222')\r\n\t\t->setMessage('Hello world from SMS')\r\n\t\t->send();\r\n\r\n}\r\nDelegation();","description":"<strong>Своими словами:</strong>\r\nОбычно нужен для того, чтоб передать работу другим связанным классам.\r\n\r\n<hr>\r\n<strong>Статья с википедиа:</strong>\r\nДелегирование (англ. Delegation) — основной шаблон проектирования, в котором объект внешне выражает некоторое поведение, но в реальности передаёт ответственность за выполнение этого поведения связанному объекту. Шаблон делегирования является фундаментальной абстракцией, на основе которой реализованы другие шаблоны - композиция (также называемая агрегацией), примеси (mixins) и аспекты (aspects).\r\n\r\n<a href=\"https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%B4%D0%B5%D0%BB%D0%B5%D0%B3%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F\">Ссылка</a>","path":"Delegation"}},{"title":"Канал событий (event channel)","data":{"code":"//пример кода :\r\n\r\n//каналов может быть много, поэтому везде делаем стандартизированные интерфейсы\r\n//для того чтоб, при добавлении нового издателя, просто всё работало без изменения кода \r\n//в других классах\r\n\r\n\r\n/**\r\n * Интерфейс канала событий\r\n * связующее звено между подписчиками и издателями\r\n */\r\ninterface EventChannelInterface {\r\n\t/**\r\n\t * Издатель уведомленяет канал о том что надо\r\n\t * всех кто подписан на тему $topic умедомить данными $data\r\n\t * \r\n\t * @param  [string] $topic [топик канала]\r\n\t * @param  [mixed] $data  [данные]\r\n\t * @return [mixed]        [description]\r\n\t */\r\n\tpublic function publish($topic, $data);\r\n\r\n\r\n\t/**\r\n\t * подписчик $subscriber подписывается на событие (данные, инфу и тп) $topic\r\n\t * \r\n\t * @param  [string]              $topic      [топик канала]\r\n\t * @param  SubscriberInterface $subscriber [подписчик]\r\n\t * @return [mixed]                          [description]\r\n\t */\r\n\tpublic function subscribe($topic, SubscriberInterface $subscriber);\r\n}\r\n\r\nclass EventChannel implements EventChannelInterface {\r\n\r\n\t//тут хранятся все издатели (Publisher) и подписчика на событие (Subscribers)\r\n\tprivate $topics = [];\r\n\r\n\r\n\tpublic function __construct(){\r\n\t\techo \"Был создан канал событий<br>\";\r\n\t}\r\n\r\n\t/**\r\n\t * Сам метод добавления подписчика на событие издателя в приватный массив\r\n\t * @param  [string]              $topic      [топик канала]\r\n\t * @param  SubscriberInterface $subscriber [подписчик]\r\n\t * @return [mixed]                          [description]\r\n\t */\r\n\tpublic function subscribe($topic, SubscriberInterface $subscriber){\r\n\t\t$this->topics[$topic][] = $subscriber;\r\n\r\n\t\techo \"{$subscriber->getName()} подписан(а) на [{$topic}]<br>\";\r\n\t}\r\n\r\n\t/**\r\n\t * Триггер на уведомление подписчиков от издателей, вот этот метод как раз и есть канал событий\r\n\t * @param  [string] $topic [топик канала]\r\n\t * @param  [string] $data  [данные какие хотим чо сюда хз]\r\n\t * @return [mixed]        [description]\r\n\t */\r\n\tpublic function publish($topic, $data) {\r\n\t\tif(empty($this->topics[$topic])) { //если нет привязки к топику канала\r\n\t\t\treturn; //то ничего не делать, сразу завершить метод\r\n\t\t}\r\n\t\techo \"Канал событий получил от издателя [{$topic}] данные [{$data}] и начал оповещать подписчиков<br>\";\r\n\t\t//прокрутим всех подписчиков из топика\r\n\t\tforeach($this->topics[$topic] as $subscriber) {\r\n\t\t\t$subscriber->notify($data); //и уведомим их об событии\r\n\t\t}\r\n\t}\r\n}\r\n\r\ninterface PublisherInterface {\r\n\t/**\r\n\t * Уведомление каналу событий о своём событии\r\n\t * далее канал уведомляет об событии подписчиков\r\n\t *\r\n\t * \r\n\t * @param  [type] $data [данные для публикции]\r\n\t * @return [mixed]       [description]\r\n\t */\r\n\tpublic function publish($data);\r\n}\r\n\r\nclass Publisher implements PublisherInterface {\r\n\t//сам издатель не знает о существовании подписчиков на него\r\n\t/**\r\n\t * Тут определяем топик этого издателя\r\n\t * @var [string]\r\n\t */\r\n\tprivate $topic;\r\n\r\n\t/**\r\n\t * Тут определяем канал событий, куда будем отправлят уведомление о событии\r\n\t * @var [EventChannelInterface]\r\n\t */\r\n\tprivate $eventChannel;\r\n\r\n\r\n\t/**\r\n\t * Во время инициализации издателя, мы должны прицепиться к каналу событий\r\n\t * @param [string] $topic        [description]\r\n\t * @param [EventChannelInterface] $eventChannel [канал событий]\r\n\t */\r\n\tpublic function __construct($topic, $eventChannel){\r\n\t\t$this->topic = $topic; //такой то топик, такая то тема\r\n\t\t$this->eventChannel = $eventChannel;\r\n\t\techo \"Был создан издатель [{$this->topic}]<br>\";\r\n\t}\r\n\r\n\t/**\r\n\t * Уведомление каналу событий о своём событии\r\n\t * далее канал уведомляет об событии подписчиков\r\n\t *\r\n\t * \r\n\t * @param  [type] $data [данные для публикции]\r\n\t * @return [mixed]       [description]\r\n\t */\r\n\tpublic function publish($data) {\r\n\t\t//отправляем событие в канал события, который уведомит всех кто подписан на этот топик\r\n\t\techo \"Издатель [{$this->topic}] отправил событие о новом посте [{$data}] каналу событий<br>\";\r\n\t\t$this->eventChannel->publish($this->topic, $data);\r\n\t}\r\n}\r\n\r\n\r\ninterface SubscriberInterface {\r\n\r\n\t/**\r\n\t * Метод уведомления подписчика о событии через EventChannel\r\n\t * @param  [string] $data [description]\r\n\t * @return [mixed]       [description]\r\n\t */\r\n\tpublic function notify($data);\r\n\r\n\t/**\r\n\t * Получить имя подписчика на событие\r\n\t * @return [string] [Имя подписчика]\r\n\t */\r\n\tpublic function getName();\r\n\r\n}\r\n\r\nclass Subscriber implements SubscriberInterface {\r\n\t/**\r\n\t * Имя подписчика\r\n\t * @var [string]\r\n\t */\r\n\tprivate $name;\r\n\r\n\tpublic function __construct($name) {\r\n\t\t$this->name = $name;\r\n\t}\r\n\r\n\t/**\r\n\t * Метод уведомления подписчика о событии через EventChannel\r\n\t * @param  [string] $data [description]\r\n\t * @return [mixed]       [description]\r\n\t */\r\n\tpublic function notify($data) {\r\n\t\techo \"{$this->getName()} оповещен(а) данными [{$data}]<br>\";\r\n\t}\r\n\r\n\t/**\r\n\t * Получить имя подписчика\r\n\t * @return [string] [имя]\r\n\t */\r\n\tpublic function getName(){\r\n\t\treturn $this->name;\r\n\t}\r\n}\r\n\r\n\r\n//класс который запускает работу канала событий и всё при всё\r\nclass EventChannelJob {\r\n\t//запуск тестового канала событий\r\n\tpublic function run() {\r\n\t\t//инициализация канала событий\r\n\t\t$newsChannel = new EventChannel(); //в нашем случае это новостной канал \r\n\r\n\t\t//подключение канала событий к издателям и создание издателя\r\n\t\t$highgardenGroup = new Publisher('highgarden-news', $newsChannel); //группа новостей хайгардена\r\n\t\t$winterfellNews = new Publisher('winterfell-news', $newsChannel); //группа новостей винтерфелла\r\n\t\t$winterfellDaily = new Publisher('winterfell-news', $newsChannel); //группа новостей альтернативного винтерфелла \r\n\r\n\t\t//создание подписчиков (получателей событий)\r\n\t\t$sansa = new Subscriber('Sansa Stark');\r\n\t\t$arya = new Subscriber('Arya Stark');\r\n\t\t$cersei = new Subscriber('Cersei Lannister');\r\n\t\t$snow = new Subscriber('Jon Snow');\r\n\r\n\t\t//связываем получателя с событием через канал событий\r\n\t\t$newsChannel->subscribe('highgarden-news', $cersei); //серсея подписывается на новости хайгардена\r\n\t\t$newsChannel->subscribe('winterfell-news', $sansa); // санса подписывается на новости винтерфелла\r\n\t\t$newsChannel->subscribe('highgarden-news', $arya); //арья подписывается на новости хайгардена\r\n\t\t$newsChannel->subscribe('winterfell-news', $arya); //а так же винтерфелла\r\n\t\t$newsChannel->subscribe('winterfell-news', $snow); //джон только на винтерфелл \r\n\r\n\t\t//создаём событие у издателя, тем самым все получатели получат уведомление о том что у издателя произошло событие\r\n\t\t//получат уведомление с помощью канала событий, который мы добавляем к издателю\r\n\t\t//т.е. у нас получается 1 канал событий (1 класс), и несколько издателей (несколько классов) в которые мы добавляем тот канал событий\r\n\t\t$highgardenGroup->publish('New highgarden post');\r\n\t\t$winterfellNews->publish('New winterfell post');\r\n\t\t$winterfellDaily->publish('New alternative winterfell post');\r\n\t}\r\n}\r\n\r\n$eventChannelJob = new EventChannelJob();\r\n$eventChannelJob->run();","description":"<strong>Своими словами:</strong>\r\nЕсть событие (event) в классе, а есть получатель события (там где мы хотим отрабатывать что то, оповещать). Получатель после получения события выполняет свой код допустим, вот посредник между ними это Event Channel который является связующим звеном.  \r\n\r\nв общем есть:\r\n- Publisher : издатель, который создаёт контент какой либо\r\n- Subscriber: подписчик на контент\r\n- Event Channel: тот который следит за событиями Publisher и в случае совпадения с группой подписки Subscriber, уведомляет его (посылает событие)\r\n\r\n<hr>\r\n<strong>Статья с википедиа:</strong>\r\nКанал событий (event channel) - фундаментальный шаблон проектирования, используется для\r\nсоздания канала связи и коммуникации через него посредством событий.\r\n\r\nЭтот канал обеспечивает возможность разным издателям публиковать\r\nсобытия и подписчикам, подписывясь на них, получать уведомления.\r\n\r\n<a href=\"https://ru.wikipedia.org/wiki/%D0%9A%D0%B0%D0%BD%D0%B0%D0%BB_%D1%81%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D0%B9_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)\">Ссылка</a>","path":"EventChannel"}},{"title":"Интерфейс (Interface)","data":{"code":"//пример тот же что и из канала событий (коротко, только сам интерфейс)\r\n\r\n//класс который запускает работу канала событий и всё при всё\r\nclass EventChannelJob { //это и есть интерфейс\r\n\t//запуск тестового канала событий\r\n\tpublic function run() {\r\n\t\t//инициализация канала событий\r\n\t\t$newsChannel = new EventChannel(); //в нашем случае это новостной канал \r\n\r\n\t\t//подключение канала событий к издателям и создание издателя\r\n\t\t$highgardenGroup = new Publisher('highgarden-news', $newsChannel); //группа новостей хайгардена\r\n\t\t$winterfellNews = new Publisher('winterfell-news', $newsChannel); //группа новостей винтерфелла\r\n\t\t$winterfellDaily = new Publisher('winterfell-news', $newsChannel); //группа новостей альтернативного винтерфелла \r\n\r\n\t\t//создание подписчиков (получателей событий)\r\n\t\t$sansa = new Subscriber('Sansa Stark');\r\n\t\t$arya = new Subscriber('Arya Stark');\r\n\t\t$cersei = new Subscriber('Cersei Lannister');\r\n\t\t$snow = new Subscriber('Jon Snow');\r\n\r\n\t\t//связываем получателя с событием через канал событий\r\n\t\t$newsChannel->subscribe('highgarden-news', $cersei); //серсея подписывается на новости хайгардена\r\n\t\t$newsChannel->subscribe('winterfell-news', $sansa); // санса подписывается на новости винтерфелла\r\n\t\t$newsChannel->subscribe('highgarden-news', $arya); //арья подписывается на новости хайгардена\r\n\t\t$newsChannel->subscribe('winterfell-news', $arya); //а так же винтерфелла\r\n\t\t$newsChannel->subscribe('winterfell-news', $snow); //джон только на винтерфелл \r\n\r\n\t\t//создаём событие у издателя, тем самым все получатели получат уведомление о том что у издателя произошло событие\r\n\t\t//получат уведомление с помощью канала событий, который мы добавляем к издателю\r\n\t\t//т.е. у нас получается 1 канал событий (1 класс), и несколько издателей (несколько классов) в которые мы добавляем тот канал событий\r\n\t\t$highgardenGroup->publish('New highgarden post');\r\n\t\t$winterfellNews->publish('New winterfell post');\r\n\t\t$winterfellDaily->publish('New alternative winterfell post');\r\n\t}\r\n}\r\n\r\n$eventChannelJob = new EventChannelJob();\r\n$eventChannelJob->run(); //вот тут мы запускаем тот самый рычажок интерфейса, который запускает внутри себя цепочку других классов","description":"<strong>Своими словами:</strong>\r\nИнтерфейс паттерн, это не interface из РНР. Стоит запомнить. Данный паттерн это нечто облегчающее работу классов, он сам по себе класс. Паттерн хранит в себе несколько экземпляров других классов для упрощения вызовов методов и работы. Потянул за рычажок интерфейса, и там внутри уже классы делают необходимую работу. Это как педаль газа в машине, нажал на неё и всё работает под капотом. По данному шаблону работают куча других шаблонов со своими компановками описанных в вики. Интерфейс просто абстрактное понятие других паттернов.\r\n\r\n<hr>\r\n<strong>Статья с википедиа:</strong>\r\n\r\nИнтерфейс (англ. interface) — основной шаблон проектирования, являющийся общим методом для структурирования компьютерных программ для того, чтобы их было проще понять. В общем, интерфейс — это класс, который обеспечивает программисту простой или более программно-специфический способ доступа к другим классам.\r\n\r\nИнтерфейс может содержать набор объектов и обеспечивать простую, высокоуровневую функциональность для программиста (например, Шаблон Фасад); он может обеспечивать более чистый или более специфический способ использования сложных классов («класс-обёртка»); он может использоваться в качестве «клея» между двумя различными API (Шаблон Адаптер); и для многих других целей.\r\n\r\nДругими типами интерфейсных шаблонов являются: Шаблон делегирования, Шаблон компоновщик, и Шаблон мост.\r\n\r\n<a href=\"https://ru.wikipedia.org/wiki/%D0%98%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)\" target=\"_blank\">Ссылка</a>","path":"InterfacePattern"}}]},{"header":"Порождающие шаблоны (Creational)","links":[{"title":"Абстрактная фабрика (Abstract factory)","data":{"code":"//Допустим у нас на сайте необходимо сделать переключение интерфейса (поменять тему)\r\n//Для этого нам необходимо реализовать генератор интерфейса GUI\r\n//Реализация будет через Абстрактную фабрику,  в которой будет:\r\n// 1) инициализация фабрики из семейства фабрик в зависимости от условий в класс инициатор\r\n// 2) Фабрика->сгенерируКнопку->нарисуй();\r\n// 3) Классу инициатора нет разницы какая фабрика будет генерировать интерфейс, класс просто запускает общий метод интерфейса\r\n// 4) Сама же Фабрика порождает семейство классов, и в классах выполняются методы\r\n\r\n\r\n\r\n//КОД:\r\n\r\n//===================интерфейсы для реализации фабрик и семейств=====================\r\n//Интерфейсы общие для семейства классов фабрики\r\ninterface ButtonInterface {\r\n\t//У всех наследуемых классов, должен быть реализован этот метод\r\n\tpublic function draw();\r\n}\r\n\r\ninterface CheckBoxInterface {\r\n\t//У всех наследуемых классов, должен быть реализован этот метод\r\n\tpublic function draw();\r\n}\r\n\r\n//Интерфейс общий для фабрик (Кит, инструментарий)\r\ninterface GuiFactoryInterface {\r\n\t//Говорим какие методы необходимо реализовать в фабриках для работы\r\n\tpublic function buildButton(): ButtonInterface;\r\n\r\n\tpublic function buildCheckBox(): CheckBoxInterface;\r\n}\r\n\r\n\r\n\r\n\r\n//================реализация семейства бутстрапа================\r\nclass ButtonBootstrap implements ButtonInterface {\r\n\tpublic function draw(){ //тут генерация html\r\n\t\techo 'Класс кнопки бутстрапа вернул результат<br>';\r\n\t\treturn __CLASS__;\r\n\t}\r\n}\r\n\r\nclass CheckBoxBootstrap implements CheckBoxInterface {\r\n\tpublic function draw(){ //тут генерация html\r\n\t\techo 'Класс чекбокса бутстрапа вернул результат<br>';\r\n\t\treturn __CLASS__;\r\n\t}\r\n}\r\n\r\n//реализация фабрики бутстрапа\r\nclass BootstrapFactory implements GuiFactoryInterface {\r\n \tpublic function buildButton(): ButtonInterface {\r\n \t\techo 'Фабрика Бутстрап создал класс кнопки<br>';\r\n \t\treturn new ButtonBootstrap();\r\n \t}\r\n\r\n \tpublic function buildCheckBox(): CheckBoxInterface {\r\n \t\techo 'Фабрика Бутстрап создал класс чекбокса<br>';\r\n \t\treturn new CheckBoxBootstrap();\r\n \t}\r\n}\r\n\r\n\r\n\r\n\r\n//======================реализация семейства симантика===================\r\nclass ButtonSemanticUi implements ButtonInterface {\r\n\tpublic function draw(){ //тут генерация html\r\n\t\techo 'Класс кнопки семантика вернул результат<br>';\r\n\t\treturn __CLASS__;\r\n\t}\r\n}\r\n\r\nclass CheckBoxSemanticUi implements CheckBoxInterface {\r\n\tpublic function draw(){ //тут генерация html\r\n\t\techo 'Класс чекбокса семантика вернул результат<br>';\r\n\t\treturn __CLASS__;\r\n\t}\r\n}\r\n//реализация фабрики семантика\r\nclass SemanticUiFactory implements GuiFactoryInterface {\r\n\tpublic function buildButton(): ButtonInterface {\r\n\t\techo 'Семантик создал класс кнопки<br>';\r\n\t\treturn new ButtonSemanticUi();\r\n \t}\r\n\r\n \tpublic function buildCheckBox(): CheckBoxInterface {\r\n \t\techo 'Семантик создал класс чекбокса<br>';\r\n \t\treturn new CheckBoxSemanticUi();\r\n \t}\r\n}\r\n\r\n\r\n\r\n\r\n\r\n//==============================Переключатель фабрик==================\r\nclass GuiKitFactory  {\r\n\r\n\t/**\r\n\t * Create Abstract Factory\r\n\t * @param  [string] $type [factory name]\r\n\t * @return [GuiFactoryInterface]       [Factory]\r\n\t */\r\n\tpublic function getFactory($type): GuiFactoryInterface {\r\n\t\t$factory;\r\n\r\n\t\tswitch ($type) {\r\n\t\t\tcase 'bootstrap': {\r\n\t\t\t\techo 'Инициализация фабрики Bootstrap<br>';\r\n\t\t\t\t$factory = new BootstrapFactory();\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase 'semanticui' : {\r\n\t\t\t\techo 'Инициализация фабрики Semantic<br>';\r\n\t\t\t\t$factory = new SemanticUiFactory();\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tdefault: {\r\n\t\t\t\texit(\"Неизвестный тип фабрики [{$type}]<br>\");\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn $factory;\r\n\t}\r\n\r\n\tpublic static function getDescription(){\r\n\t\treturn 1;\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n//=====================запуск====================\r\nclass ExampleClass {\r\n\r\n\t/**\r\n\t * Переключалка между фабриками\r\n\t * @var [GuiFactoryInterface]\r\n\t */\r\n\tprivate $guiKit;\r\n\r\n\tpublic function __construct(){\r\n\t\t//изначально выставляем фабрику bootstrap\r\n\t\t$this->guiKit = (new GuiKitFactory())->getFactory('bootstrap');\r\n\t\t//$this->guiKit = (new GuiKitFactory())->getFactory('semanticui');\r\n\t}\r\n\r\n\r\n\tpublic function AbstractFactory(){\r\n\t\t$name = 'Абстрактная фабрика';\r\n\t\t$description = GuiKitFactory::getDescription();\r\n\r\n\t\t//фабрика генерирует кнопку и чекбокс \r\n\t\t$result[] = $this->guiKit->buildButton()->draw();\r\n\t\t$result[] = $this->guiKit->buildCheckBox()->draw();\r\n\r\n\t\tvar_dump($description);\r\n\t\tvar_dump($result);\r\n\t}\r\n}\r\n\r\n$test = new ExampleClass();\r\n$test->AbstractFactory();","description":"<strong>Своими словами:</strong>\r\nАбстрактная фабрика это такой класс который может порождать внутри себя несколько классов которые наследуются по какому либо одному интерфейсу, так же сами фабрики могут наследоваться от одного интерфейса. \r\n\r\nВ абстрактной фабрике может быть несколько семейств порождённых классов, но они никак не должны контактировать друг с другом. Например семейство классов ClassA и семейство классов ClassB наследуются от одного интерфейса. Реализация у всех разная, но методы наследуемые от интерфейса одинаковые.\r\n\r\nТак же самих Абстрактных фабрик может быть несколько, они так же должны быть наследованы от одного семейства (интерфейса) и не должны контактировать друг с другом. Например ClassFactoryA и ClassFactoryB наследуются от одного интерфейса. Реализация у всех разная, но методы наследуемые от интерфейса одинаковые.\r\n\r\nДля нескольких фабрик одного семейства необходимо реализовать класс который умеет переключать эти фабрики в зависимости от условий. Т.к. интерфейс общий, то и выходящие методы тоже общие. А значит переключение будет безболезненным. \r\n\r\n<hr>\r\n<strong>Статья с refactoring.guru:</strong>\r\n\r\nАбстрактная фабрика — это порождающий паттерн проектирования, который позволяет создавать семейства связанных объектов, не привязываясь к конкретным классам создаваемых объектов.\r\n\r\n<a href=\"https://refactoring.guru/ru/design-patterns/abstract-factory\" target=\"_blank\">Ссылка</a>\r\n\r\n<a href=\"https://refactoring.guru/ru/design-patterns/factory-comparison\" target=\"_blank\">Ссылка на сравнение фабрик</a>\r\n\r\n<hr>\r\n<strong>Статья с википедиа:</strong>\r\nАбстрактная фабрика (англ. Abstract factory) — порождающий шаблон проектирования, предоставляет интерфейс для создания семейств взаимосвязанных или взаимозависимых объектов, не специфицируя их конкретных классов. Шаблон реализуется созданием абстрактного класса Factory, который представляет собой интерфейс для создания компонентов системы (например, для оконного интерфейса он может создавать окна и кнопки). Затем пишутся классы, реализующие этот интерфейс[2].\r\n\r\n<a href=\"https://ru.wikipedia.org/wiki/%D0%90%D0%B1%D1%81%D1%82%D1%80%D0%B0%D0%BA%D1%82%D0%BD%D0%B0%D1%8F_%D1%84%D0%B0%D0%B1%D1%80%D0%B8%D0%BA%D0%B0_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)\" target=\"_blank\">Ссылка</a>","path":"AbstractFactory"}},{"title":"Фабричный метод (Factory Method)","data":{"code":"//Допустим у нас на сайте необходимо сделать переключение интерфейса (поменять тему)\r\n//Для этого нам необходимо реализовать генератор интерфейса GUI\r\n//Реализация будет через Фабричный метод,  в котором будет:\r\n// 1) Инициализация дочернего класса наследуюемого от суперкласса \r\n// 2) Дочерний класс вызывает метод суперкласса генерации: дочерний->рендер();\r\n// 3) Суперкласс в свою очередь вызывает метод дочернего для пораждения фабрики  получитьФабрику();\r\n// 4) Дочерний пораждает фабрику и возвращает суперклассу\r\n// 5) Суперкласс реализовывает механику пораждённой фабрики внутри себя\r\n// Т.е. у нас получается все дочерние классы могут порождать разные фабрики, и все они будут ссылаться на суперкласс, который реализует механику\r\n\r\n/**\r\n * Интерфейс фабричного метода, для реализации методов в дочерних элементах\r\n */\r\ninterface FormInterface {\r\n\tpublic function render();\r\n\r\n\tfunction createGuiKit(): GuiFactoryInterface;\r\n}\r\n\r\n\r\n\r\n//===================интерфейсы для реализации фабрик и семейств=====================\r\n//Интерфейсы общие для семейства классов фабрики\r\ninterface ButtonInterface {\r\n\t//У всех наследуемых классов, должен быть реализован этот метод\r\n\tpublic function draw();\r\n}\r\n\r\ninterface CheckBoxInterface {\r\n\t//У всех наследуемых классов, должен быть реализован этот метод\r\n\tpublic function draw();\r\n}\r\n\r\n//Интерфейс общий для фабрик (Кит, инструментарий)\r\ninterface GuiFactoryInterface {\r\n\t//Говорим какие методы необходимо реализовать в фабриках для работы\r\n\tpublic function buildButton(): ButtonInterface;\r\n\r\n\tpublic function buildCheckBox(): CheckBoxInterface;\r\n}\r\n\r\n\r\n\r\n//================реализация семейства бутстрапа================\r\nclass ButtonBootstrap implements ButtonInterface {\r\n\tpublic function draw(){ //тут генерация html\r\n\t\techo 'Класс кнопки бутстрапа вернул результат<br>';\r\n\t\treturn __CLASS__;\r\n\t}\r\n}\r\n\r\nclass CheckBoxBootstrap implements CheckBoxInterface {\r\n\tpublic function draw(){ //тут генерация html\r\n\t\techo 'Класс чекбокса бутстрапа вернул результат<br>';\r\n\t\treturn __CLASS__;\r\n\t}\r\n}\r\n\r\n//реализация фабрики бутстрапа\r\nclass BootstrapFactory implements GuiFactoryInterface {\r\n \tpublic function buildButton(): ButtonInterface {\r\n \t\techo 'Фабрика Бутстрап создал класс кнопки<br>';\r\n \t\treturn new ButtonBootstrap();\r\n \t}\r\n\r\n \tpublic function buildCheckBox(): CheckBoxInterface {\r\n \t\techo 'Фабрика Бутстрап создал класс чекбокса<br>';\r\n \t\treturn new CheckBoxBootstrap();\r\n \t}\r\n}\r\n\r\n\r\n\r\n\r\n//======================реализация семейства симантика===================\r\nclass ButtonSemanticUi implements ButtonInterface {\r\n\tpublic function draw(){ //тут генерация html\r\n\t\techo 'Класс кнопки семантика вернул результат<br>';\r\n\t\treturn __CLASS__;\r\n\t}\r\n}\r\n\r\nclass CheckBoxSemanticUi implements CheckBoxInterface {\r\n\tpublic function draw(){ //тут генерация html\r\n\t\techo 'Класс чекбокса семантика вернул результат<br>';\r\n\t\treturn __CLASS__;\r\n\t}\r\n}\r\n//реализация фабрики семантика\r\nclass SemanticUiFactory implements GuiFactoryInterface {\r\n\tpublic function buildButton(): ButtonInterface {\r\n\t\techo 'Семантик создал класс кнопки<br>';\r\n\t\treturn new ButtonSemanticUi();\r\n \t}\r\n\r\n \tpublic function buildCheckBox(): CheckBoxInterface {\r\n \t\techo 'Семантик создал класс чекбокса<br>';\r\n \t\treturn new CheckBoxSemanticUi();\r\n \t}\r\n}\r\n\r\n\r\n//======================реализация фабричного метода===================\r\n/**\r\n * допустим абстрактная форма генерирующая диалоговое окно\r\n *\r\n * суперкласс который реализовывает в себе механики работы фабрик дочерних классов\r\n */\r\nabstract class AbstractForm implements FormInterface {\r\n\t\r\n\t/**\r\n\t * В абстрактном классе есть логика генерации формы\r\n\t * реализация фабрики\r\n\t * @return [mixed] [result]\r\n\t */\r\n\tpublic function render(){\r\n\r\n\t\t$guiKit = $this->createGuiKit(); //получить некий инструментарий для отрисовки  \r\n\t\t$name = get_class($guiKit);\r\n\t\techo \"Суперкласс реализовывает механику работы от дочернего класса [{$name}]<br>\";\r\n\t\t//сгенерировать GUI формы\r\n\t\t$result[] = $guiKit->buildCheckBox()->draw();\r\n\t\t$result[] = $guiKit->buildButton()->draw();\r\n\r\n\t\treturn $result;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Получаем инструментарий (фабрику) для рисования объектов формы \r\n\t * данный метод должен быть реализован в наследуемых классах\r\n\t * @return [GuiFactoryInterface] [инструментарий (фабрика)]\r\n\t */\r\n\tabstract function createGuiKit(): GuiFactoryInterface;\r\n}\r\n\r\n\r\n/**\r\n * В наследуюемом классе реализуем пораждение инструментария \r\n * для возврата в абстрактную фабрику для работы\r\n */\r\nclass BootstrapDialogForm extends AbstractForm {\r\n\t/**\r\n\t * Дочерний элемент создаёт инструментарий (фабрику)\r\n\t * @return [GuiFactoryInterface] [Инструментарий]\r\n\t */\r\n\tpublic function createGuiKit(): GuiFactoryInterface {\r\n\t\techo \"Дочерний класс порадил фабрику BootStrap<br>\";\r\n\t\treturn new BootstrapFactory();\r\n\t}\r\n}\r\n\r\n/**\r\n * В наследуюемом классе реализуем пораждение инструментария \r\n * для возврата в абстрактную фабрику для работы\r\n */\r\nclass SemanticUiDialogForm extends AbstractForm {\r\n\t/**\r\n\t * Дочерний элемент создаёт инструментарий (фабрику)\r\n\t * @return [GuiFactoryInterface] [Инструментарий]\r\n\t */\r\n\tpublic function createGuiKit(): GuiFactoryInterface {\r\n\t\techo \"Дочерний класс порадил фабрику Semantic<br>\";\r\n\t\treturn new SemanticUiFactory();\r\n\t}\r\n}\r\n\r\n\r\n//=====================запуск====================\r\n\r\nclass ExampleClass {\r\n\tpublic function FactoryMethod() {\r\n\t\t$name = 'Фабричный метод';\r\n\t\t//создание фабричного инструментария\r\n\t\t$dialogForm = new BootstrapDialogForm();\r\n\t\t//$dialogForm = new SemanticUiDialogForm();\r\n\t\t//вызов реализации механики работы фабрики из абстрактного класса\r\n\t\t$result = $dialogForm->render();\r\n\t\tvar_dump($result);\r\n\t}\r\n}\r\n\r\n$test = new ExampleClass();\r\n$test->FactoryMethod();\r\n","description":"<strong>Cвоими словами: </strong>\r\nФабричный метод подразумевает основную механику работы с фабриками внутри абстрактного суперкласса. \r\n\r\n!Т.е. у нас есть суперкласс и есть дочерние классы которые наследованы от него. \r\nМы не можем породить суперкласс т.к. он абстрактный, мы можем породить только дочерние классы, и от дочернего будет работать суперкласс. \r\nВсе дочерние классы (наследованные от суперкласса) могут порождать разные фабрики вернув их в суперкласс,  который в свою очередь реализует механику работы этих фабрик.\r\n\r\n<hr>\r\n<strong>Статья с refactoring.guru: </strong>\r\nФабричный метод — это порождающий паттерн проектирования, который определяет общий интерфейс для создания объектов в суперклассе, позволяя подклассам изменять тип создаваемых объектов.\r\n\r\n<a href=\"https://refactoring.guru/ru/design-patterns/factory-method\" target=\"_blank\">Ссылка</a>\r\n\r\n<hr>\r\n<strong>Статья с википедиа: </strong>\r\nФабричный метод (англ. Factory Method), или виртуальный конструктор (англ. Virtual Constructor) — порождающий шаблон проектирования, предоставляющий подклассам (дочерним классам) интерфейс для создания экземпляров некоторого класса. В момент создания наследники могут определить, какой класс создавать. Иными словами, данный шаблон делегирует создание объектов наследникам родительского класса. Это позволяет использовать в коде программы не специфические классы, а манипулировать абстрактными объектами на более высоком уровне.\r\n\r\n<a href=\"https://ru.wikipedia.org/wiki/%D0%A4%D0%B0%D0%B1%D1%80%D0%B8%D1%87%D0%BD%D1%8B%D0%B9_%D0%BC%D0%B5%D1%82%D0%BE%D0%B4_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)\" target=\"_blank\">Ссылка</a>","path":"Factory Method"}},{"title":"Статическая фабрика (Static factory)","data":{"code":"//будем использовать один из шаблонов проектирование (Delegation) и обернём его статической фабрикой\r\n//интерфейс делегирования\r\ninterface MessengerInterface {\r\n\t//установить отправителя\r\n\tpublic function setSender($value): MessengerInterface;\r\n\r\n\t//установить получателя\r\n\tpublic function setRecipient($value): MessengerInterface;\r\n\r\n\t//установить сообщение\r\n\tpublic function setMessage($value): MessengerInterface;\r\n\r\n\t//отправить сообщение\r\n\tpublic function send():bool; \r\n}\r\n\r\n//интерфейс статической фабрики\r\ninterface StaticFactoryInterface {\r\n\t/**\r\n\t * Фабрика должна реализовать методы данного интерфейса\r\n\t * @param  [string] $type [наименование класса]\r\n\t * @return [mixed]       [object]\r\n\t */\r\n\tpublic static function build($type);\r\n}\r\n\r\n//Абстрактный класс, который реализовывает базовые методы интерфейса\r\n//последующие классы наследуются от абстрактного класса, для дальнейшей реализации\r\nabstract class AbstractMessenger implements MessengerInterface {\r\n\tprotected $sender; //отправитель\r\n\r\n\tprotected $recipient; //получатель\r\n\r\n\tprotected $message; //сообщение \r\n\r\n\t//установить отправителя\r\n\tpublic function setSender($value) : MessengerInterface\r\n\t{\r\n\t\t$this->sender = $value;\r\n\t\treturn $this;\r\n\t}\r\n\r\n\t//установить получателя\r\n\tpublic function setRecipient($value): MessengerInterface\r\n\t{\r\n\t\t$this->recipient = $value;\r\n\t\treturn $this;\r\n\t}\r\n\r\n\tpublic function setMessage($value): MessengerInterface\r\n\t{\r\n\t\t$this->message = $value;\r\n\t\treturn $this;\r\n\t}\r\n\r\n\t//отправить сообщение\r\n\tpublic function send(): bool \r\n\t{\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\n//т.к. мы наследуемся от абстрактного класса, то метод send() будет перегружен,\r\n//поэтому, мы отправляем сенд на абстрактный класс через parrent\r\n//\r\nclass EmailMessenger extends AbstractMessenger {\r\n\t//тут много кода по реализации отправки по email\r\n\tpublic function send(): bool \r\n\t{\r\n\t\t//тут код отправки\r\n\t\techo 'Send by Email<br>';\r\n\t\treturn parent::send(); //отправляем из абстрактного класса\r\n\t}\r\n}\r\n\r\nclass SmsMessenger extends AbstractMessenger {\r\n\t//тут много кода реализации отправки по СМС\r\n\tpublic function send(): bool \r\n\t{\r\n\t\t//тут код отправки\r\n\t\techo 'Send by SMS<br>';\r\n\t\treturn parent::send(); //отправляем из абстрактного класса\r\n\t}\r\n}\r\n\r\n//сам класс который будет делегировать \r\nclass AppMessenger implements MessengerInterface {\r\n\t\r\n\t//приватное свойство messenger, это тот, на кого мы будем делегировать работу (экземпляр класса)\r\n\tprivate $messenger; \r\n\r\n\tpublic function __construct(){\r\n\t\t//по дефолту вызывем метод toEmail где у нас создаётся класс EmailMessenger и присваивается в messenger переменную\r\n\t\t//это нужно чтоб ничто не сломалось\r\n\t\t$this->toEmail(); \r\n\t}\r\n\r\n\tstatic public function getDescription() {\r\n\r\n\t}\r\n\r\n\t//если по email, то вернём экземпляр класса \r\n\t//EmailMessenger и ещё присвоим его в переменную messenger\r\n\tpublic function toEmail(){ \r\n\t\t$this->messenger = new EmailMessenger();\r\n\t\treturn $this;\r\n\t}\r\n\r\n\r\n\t//если по sms, то вернём экземпляр класса\r\n\t//SmsMessenger и ещё присвоим его в переменную messenger\r\n\tpublic function toSMS(){\r\n\t\t//т.к. у нас изначально toEmail, то тут мы просто перезапишем в messenger новый экземпляр класса SmsMessenger\r\n\t\t$this->messenger = new SmsMessenger();\r\n\t\treturn $this;\r\n\t}\r\n\r\n\t//т.к. у нас данный класс так же наследуется от интерфейса, то нам необходимо реализовать его методы\r\n\tpublic function setSender($value): MessengerInterface { //обязательно возвращаемый у нас будет MessengerInterface\r\n\t\t$this->messenger->setSender($value); //но тут мы будем делегировать методы в тот класс, который породили в messenger\r\n\t\treturn $this->messenger;\r\n\t}\r\n\r\n\t//т.к. у нас данный класс так же наследуется от интерфейса, то нам необходимо реализовать его методы\r\n\tpublic function setRecipient($value): MessengerInterface { //обязательно возвращаемый у нас будет MessengerInterface\r\n\t\t$this->messenger->setRecipient($value); //но тут мы будем делегировать методы в тот класс, который породили в messenger\r\n\t\treturn $this->messenger;\r\n\t}\r\n\t\r\n\t//т.к. у нас данный класс так же наследуется от интерфейса, то нам необходимо реализовать его методы\r\n\tpublic function setMessage($value): MessengerInterface {\r\n\t\t$this->messenger->setMessage($value); //но тут мы будем делегировать методы в тот класс, который породили в messenger\r\n\t\treturn $this->messenger;\r\n\t}\r\n\r\n\r\n\t//т.к. у нас данный класс так же наследуется от интерфейса, то нам необходимо реализовать его методы\r\n\tpublic function send(): bool {\r\n\t\treturn $this->messenger->send(); //но тут мы будем делегировать методы в тот класс, который породили в messenger\r\n\t}\r\n\r\n}\r\n\r\n//реализация статической фабрики\r\n\r\nclass StaticFactory implements StaticFactoryInterface {\r\n\tpublic static function build($type = 'email') {\r\n\t\t$item = new AppMessenger();\r\n\t\tswitch($type) {\r\n\t\t\tcase 'email' : {\r\n\t\t\t\t$item->toEmail()\r\n\t\t\t\t->setSender('Default Sender')\r\n\t\t\t\t->setRecipient('default@example.com');\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase 'sms' : {\r\n\t\t\t\t$item->toSms()\r\n\t\t\t\t->setSender('Default Sender')\r\n\t\t\t\t->setRecipient('8888888888');\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tdefault:{\r\n\t\t\t\tthrow new Exception(\"Invalid type [{$type}]\", 1);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\t$item->setMessage('Default message');\r\n\t\treturn $item;\r\n\t}\r\n}\r\n\r\n//применение:\r\n$sendEmail = StaticFactory::build('email');\r\n$sendSMS = StaticFactory::build('sms');\r\n\r\n$sendEmail->send();\r\nvar_dump($sendEmail, $sendSMS);","description":"<strong>Своими словами:</strong>\r\nСтатическая фабрика это некий вид простой фабрики, которая порождает объекты (экземпляры классов) с помощью статического метода и делает базовые настройки данного объекта. Т.е. у нас есть класс фабрики (StaticFactory) и в нём есть статический метод (public static build()), и там уже в параметрах выставляется какой объект нужно породить.\r\n\r\n<strong>Остальные объяснения:</strong>\r\nВ интернете нет чёткого представления по этой фабрике. Поэтому делаем так как поняли сами.","path":"Static factory"}}]},{"header":"Структурные шаблоны (Structural)"},{"header":"Поведенческие шаблоны (Behavioral)"},{"header":"Свои наработки других ЯП (Other)"}]