[{"header":"Основные (Fundamental)","links":[{"title":"Контейнер свойств (property container)","data":{"path":"PropertyContainer","description":"<strong>Своими словами:</strong>\r\nобычно нужен для того, что бы расширить свойства класса путём динамического добавления\r\nчто бы не надо было лезть в класс и постоянно писать какие то дополнительные переменные\r\n\r\n<hr>\r\n<strong>Статья с википедиа:</strong>\r\nКонтейнер свойств (англ. property container) — фундаментальный шаблон проектирования, который служит для обеспечения возможности уже построенного и развернутого приложения\r\n\r\n<a href=\"https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BD%D1%82%D0%B5%D0%B9%D0%BD%D0%B5%D1%80_%D1%81%D0%B2%D0%BE%D0%B9%D1%81%D1%82%D0%B2_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)\" target=\"_blank\">Ссылка</a>\r\n","code":"//интерфейс нужен для того что бы обозначить правила классов, которые наследуются от него, какие методы необходимо реализовать \r\ninterface PropertyInterface {\r\n\tfunction AddProperty($propertyName, $value); //создать свойство с данными\r\n\tfunction DeleteProperty($propertyName); //удалить свойство \r\n\tfunction GetProperty($propertyName); //получить данные из свойства \r\n\tfunction SetProperty($propertyName, $value); //обновить данные в свойстве \r\n\t\r\n}\r\n\r\n//класс контейнер наследуется от интерфейса для реализации логики по правилам интерфейса\r\nclass PropertyContainer extends PropertyInterface {\r\n\tprivate $propertyContainer = [];\r\n\t\r\n\tpublic function AddProperty($propertyName, $value) {\r\n\t\t$this->propertyContainer[$propertyName] = $value;\r\n\t}\r\n\t\r\n\tpublic function DeleteProperty($propertyName) {\r\n\t\tunset(propertyContainer[$propertyName]);\r\n\t}\r\n\t\r\n\tpublic function GetProperty($propertyName) {\r\n\t\treturn $this->propertyContainer[$propertyName] ?? null;\r\n\t}\r\n\t\r\n\tpublic function SetProperty($propertyName, $value) {\r\n\t\tif(!isset($this->propertyContainer[$propertyName])) {\r\n\t\t\tthrow new Exception(\"Property [{$propertyName}] is not found\");\r\n\t\t}\r\n\t\t$this->propertyContainer[$propertyName] = $value;\r\n\t}\r\n}\r\n\r\n\r\n//допустим есть класс \r\n//в классе всегда лучше оставлять линк на то, какой ты шаблон проектирования использовал\r\nclass BlogPost extends PropertyContainer {\r\n\t//used pattern https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BD%D1%82%D0%B5%D0%B9%D0%BD%D0%B5%D1%80_%D1%81%D0%B2%D0%BE%D0%B9%D1%81%D1%82%D0%B2_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)\r\n\t//some...\r\n\t//functions bla bla \r\n}\r\n\r\n//применение:\r\n$blog = new BlogPost();\r\n$blog->AddProperty('name', 'Ras');\r\n$name = $blog->GetProperty('name');\r\n$blog->SetProperty('name', 'saR');\r\n$blog->DeleteProperty('name');"}},{"title":"Делегирование (Delegation)","data":{"code":"//ну для начала реализуем интерфейс, по которому нужно будет реализовывать наследуюемые классы\r\ninterface MessengerInterface {\r\n\t//установить отправителя\r\n\tpublic function setSender($value): MessengerInterface;\r\n\r\n\t//установить получателя\r\n\tpublic function setRecipient($value): MessengerInterface;\r\n\r\n\t//установить сообщение\r\n\tpublic function setMessage($value): MessengerInterface;\r\n\r\n\t//отправить сообщение\r\n\tpublic function send():bool; \r\n}\r\n\r\n//Абстрактный класс, который реализовывает базовые методы интерфейса\r\n//последующие классы наследуются от абстрактного класса, для дальнейшей реализации\r\nabstract class AbstractMessenger implements MessengerInterface {\r\n\tprotected $sender; //отправитель\r\n\r\n\tprotected $recipient; //получатель\r\n\r\n\tprotected $message; //сообщение \r\n\r\n\t//установить отправителя\r\n\tpublic function setSender($value) : MessengerInterface\r\n\t{\r\n\t\t$this->sender = $value;\r\n\t\treturn $this;\r\n\t}\r\n\r\n\t//установить получателя\r\n\tpublic function setRecipient($value): MessengerInterface\r\n\t{\r\n\t\t$this->recipient = $value;\r\n\t\treturn $this;\r\n\t}\r\n\r\n\tpublic function setMessage($value): MessengerInterface\r\n\t{\r\n\t\t$this->message = $value;\r\n\t\treturn $this;\r\n\t}\r\n\r\n\t//отправить сообщение\r\n\tpublic function send(): bool \r\n\t{\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\n//т.к. мы наследуемся от абстрактного класса, то метод send() будет перегружен,\r\n//поэтому, мы отправляем сенд на абстрактный класс через parrent\r\n//\r\nclass EmailMessenger extends AbstractMessenger {\r\n\t//тут много кода по реализации отправки по email\r\n\tpublic function send(): bool \r\n\t{\r\n\t\t//тут код отправки\r\n\t\techo 'Send by Email<br>';\r\n\t\treturn parent::send(); //отправляем из абстрактного класса\r\n\t}\r\n}\r\n\r\nclass SmsMessenger extends AbstractMessenger {\r\n\t//тут много кода реализации отправки по СМС\r\n\tpublic function send(): bool \r\n\t{\r\n\t\t//тут код отправки\r\n\t\techo 'Send by SMS<br>';\r\n\t\treturn parent::send(); //отправляем из абстрактного класса\r\n\t}\r\n}\r\n\r\n//сам класс который будет делегировать \r\nclass AppMessenger implements MessengerInterface {\r\n\t\r\n\t//приватное свойство messenger, это тот, на кого мы будем делегировать работу (экземпляр класса)\r\n\tprivate $messenger; \r\n\r\n\tpublic function __construct(){\r\n\t\t//по дефолту вызывем метод toEmail где у нас создаётся класс EmailMessenger и присваивается в messenger переменную\r\n\t\t//это нужно чтоб ничто не сломалось\r\n\t\t$this->toEmail(); \r\n\t}\r\n\r\n\tstatic public function getDescription() {\r\n\r\n\t}\r\n\r\n\t//если по email, то вернём экземпляр класса \r\n\t//EmailMessenger и ещё присвоим его в переменную messenger\r\n\tpublic function toEmail(){ \r\n\t\t$this->messenger = new EmailMessenger();\r\n\t\treturn $this;\r\n\t}\r\n\r\n\r\n\t//если по sms, то вернём экземпляр класса\r\n\t//SmsMessenger и ещё присвоим его в переменную messenger\r\n\tpublic function toSMS(){\r\n\t\t//т.к. у нас изначально toEmail, то тут мы просто перезапишем в messenger новый экземпляр класса SmsMessenger\r\n\t\t$this->messenger = new SmsMessenger();\r\n\t\treturn $this;\r\n\t}\r\n\r\n\t//т.к. у нас данный класс так же наследуется от интерфейса, то нам необходимо реализовать его методы\r\n\tpublic function setSender($value): MessengerInterface { //обязательно возвращаемый у нас будет MessengerInterface\r\n\t\t$this->messenger->setSender($value); //но тут мы будем делегировать методы в тот класс, который породили в messenger\r\n\t\treturn $this->messenger;\r\n\t}\r\n\r\n\t//т.к. у нас данный класс так же наследуется от интерфейса, то нам необходимо реализовать его методы\r\n\tpublic function setRecipient($value): MessengerInterface { //обязательно возвращаемый у нас будет MessengerInterface\r\n\t\t$this->messenger->setRecipient($value); //но тут мы будем делегировать методы в тот класс, который породили в messenger\r\n\t\treturn $this->messenger;\r\n\t}\r\n\t\r\n\t//т.к. у нас данный класс так же наследуется от интерфейса, то нам необходимо реализовать его методы\r\n\tpublic function setMessage($value): MessengerInterface {\r\n\t\t$this->messenger->setMessage($value); //но тут мы будем делегировать методы в тот класс, который породили в messenger\r\n\t\treturn $this->messenger;\r\n\t}\r\n\r\n\r\n\t//т.к. у нас данный класс так же наследуется от интерфейса, то нам необходимо реализовать его методы\r\n\tpublic function send(): bool {\r\n\t\treturn $this->messenger->send(); //но тут мы будем делегировать методы в тот класс, который породили в messenger\r\n\t}\r\n\r\n}\r\n\r\n//применение:\r\nfunction Delegation() {\r\n\t$name = 'Делегирование (Delegation)';\r\n\t$description = AppMessenger::getDescription();\r\n\r\n\t$item = new AppMessenger();\r\n\r\n\t//ну по дефолту у нас email, поэтому так и оставляем\r\n\t$item->setSender('sender@example.com')\r\n\t\t->setRecipient('recipitne@example.com')\r\n\t\t->setMessage('Hello world from email')\r\n\t\t->send();\r\n\r\n\t//но если у нас sms то в начале устанавливаем toSms\r\n\t$item->toSms()\r\n\t\t->setSender('1111111111')\r\n\t\t->setRecipient('2222222222')\r\n\t\t->setMessage('Hello world from SMS')\r\n\t\t->send();\r\n\r\n}\r\nDelegation();","description":"<strong>Своими словами:</strong>\r\nОбычно нужен для того, чтоб передать работу другим связанным классам.\r\n\r\n<hr>\r\n<strong>Статья с википедиа:</strong>\r\nДелегирование (англ. Delegation) — основной шаблон проектирования, в котором объект внешне выражает некоторое поведение, но в реальности передаёт ответственность за выполнение этого поведения связанному объекту. Шаблон делегирования является фундаментальной абстракцией, на основе которой реализованы другие шаблоны - композиция (также называемая агрегацией), примеси (mixins) и аспекты (aspects).\r\n\r\n<a href=\"https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%B4%D0%B5%D0%BB%D0%B5%D0%B3%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F\">Ссылка</a>","path":"Delegation"}},{"title":"Канал событий (event channel)","data":{"code":"//пример кода :\r\n\r\n//каналов может быть много, поэтому везде делаем стандартизированные интерфейсы\r\n//для того чтоб, при добавлении нового издателя, просто всё работало без изменения кода \r\n//в других классах\r\n\r\n\r\n/**\r\n * Интерфейс канала событий\r\n * связующее звено между подписчиками и издателями\r\n */\r\ninterface EventChannelInterface {\r\n\t/**\r\n\t * Издатель уведомленяет канал о том что надо\r\n\t * всех кто подписан на тему $topic умедомить данными $data\r\n\t * \r\n\t * @param  [string] $topic [топик канала]\r\n\t * @param  [mixed] $data  [данные]\r\n\t * @return [mixed]        [description]\r\n\t */\r\n\tpublic function publish($topic, $data);\r\n\r\n\r\n\t/**\r\n\t * подписчик $subscriber подписывается на событие (данные, инфу и тп) $topic\r\n\t * \r\n\t * @param  [string]              $topic      [топик канала]\r\n\t * @param  SubscriberInterface $subscriber [подписчик]\r\n\t * @return [mixed]                          [description]\r\n\t */\r\n\tpublic function subscribe($topic, SubscriberInterface $subscriber);\r\n}\r\n\r\nclass EventChannel implements EventChannelInterface {\r\n\r\n\t//тут хранятся все издатели (Publisher) и подписчика на событие (Subscribers)\r\n\tprivate $topics = [];\r\n\r\n\r\n\tpublic function __construct(){\r\n\t\techo \"Был создан канал событий<br>\";\r\n\t}\r\n\r\n\t/**\r\n\t * Сам метод добавления подписчика на событие издателя в приватный массив\r\n\t * @param  [string]              $topic      [топик канала]\r\n\t * @param  SubscriberInterface $subscriber [подписчик]\r\n\t * @return [mixed]                          [description]\r\n\t */\r\n\tpublic function subscribe($topic, SubscriberInterface $subscriber){\r\n\t\t$this->topics[$topic][] = $subscriber;\r\n\r\n\t\techo \"{$subscriber->getName()} подписан(а) на [{$topic}]<br>\";\r\n\t}\r\n\r\n\t/**\r\n\t * Триггер на уведомление подписчиков от издателей, вот этот метод как раз и есть канал событий\r\n\t * @param  [string] $topic [топик канала]\r\n\t * @param  [string] $data  [данные какие хотим чо сюда хз]\r\n\t * @return [mixed]        [description]\r\n\t */\r\n\tpublic function publish($topic, $data) {\r\n\t\tif(empty($this->topics[$topic])) { //если нет привязки к топику канала\r\n\t\t\treturn; //то ничего не делать, сразу завершить метод\r\n\t\t}\r\n\t\techo \"Канал событий получил от издателя [{$topic}] данные [{$data}] и начал оповещать подписчиков<br>\";\r\n\t\t//прокрутим всех подписчиков из топика\r\n\t\tforeach($this->topics[$topic] as $subscriber) {\r\n\t\t\t$subscriber->notify($data); //и уведомим их об событии\r\n\t\t}\r\n\t}\r\n}\r\n\r\ninterface PublisherInterface {\r\n\t/**\r\n\t * Уведомление каналу событий о своём событии\r\n\t * далее канал уведомляет об событии подписчиков\r\n\t *\r\n\t * \r\n\t * @param  [type] $data [данные для публикции]\r\n\t * @return [mixed]       [description]\r\n\t */\r\n\tpublic function publish($data);\r\n}\r\n\r\nclass Publisher implements PublisherInterface {\r\n\t//сам издатель не знает о существовании подписчиков на него\r\n\t/**\r\n\t * Тут определяем топик этого издателя\r\n\t * @var [string]\r\n\t */\r\n\tprivate $topic;\r\n\r\n\t/**\r\n\t * Тут определяем канал событий, куда будем отправлят уведомление о событии\r\n\t * @var [EventChannelInterface]\r\n\t */\r\n\tprivate $eventChannel;\r\n\r\n\r\n\t/**\r\n\t * Во время инициализации издателя, мы должны прицепиться к каналу событий\r\n\t * @param [string] $topic        [description]\r\n\t * @param [EventChannelInterface] $eventChannel [канал событий]\r\n\t */\r\n\tpublic function __construct($topic, $eventChannel){\r\n\t\t$this->topic = $topic; //такой то топик, такая то тема\r\n\t\t$this->eventChannel = $eventChannel;\r\n\t\techo \"Был создан издатель [{$this->topic}]<br>\";\r\n\t}\r\n\r\n\t/**\r\n\t * Уведомление каналу событий о своём событии\r\n\t * далее канал уведомляет об событии подписчиков\r\n\t *\r\n\t * \r\n\t * @param  [type] $data [данные для публикции]\r\n\t * @return [mixed]       [description]\r\n\t */\r\n\tpublic function publish($data) {\r\n\t\t//отправляем событие в канал события, который уведомит всех кто подписан на этот топик\r\n\t\techo \"Издатель [{$this->topic}] отправил событие о новом посте [{$data}] каналу событий<br>\";\r\n\t\t$this->eventChannel->publish($this->topic, $data);\r\n\t}\r\n}\r\n\r\n\r\ninterface SubscriberInterface {\r\n\r\n\t/**\r\n\t * Метод уведомления подписчика о событии через EventChannel\r\n\t * @param  [string] $data [description]\r\n\t * @return [mixed]       [description]\r\n\t */\r\n\tpublic function notify($data);\r\n\r\n\t/**\r\n\t * Получить имя подписчика на событие\r\n\t * @return [string] [Имя подписчика]\r\n\t */\r\n\tpublic function getName();\r\n\r\n}\r\n\r\nclass Subscriber implements SubscriberInterface {\r\n\t/**\r\n\t * Имя подписчика\r\n\t * @var [string]\r\n\t */\r\n\tprivate $name;\r\n\r\n\tpublic function __construct($name) {\r\n\t\t$this->name = $name;\r\n\t}\r\n\r\n\t/**\r\n\t * Метод уведомления подписчика о событии через EventChannel\r\n\t * @param  [string] $data [description]\r\n\t * @return [mixed]       [description]\r\n\t */\r\n\tpublic function notify($data) {\r\n\t\techo \"{$this->getName()} оповещен(а) данными [{$data}]<br>\";\r\n\t}\r\n\r\n\t/**\r\n\t * Получить имя подписчика\r\n\t * @return [string] [имя]\r\n\t */\r\n\tpublic function getName(){\r\n\t\treturn $this->name;\r\n\t}\r\n}\r\n\r\n\r\n//класс который запускает работу канала событий и всё при всё\r\nclass EventChannelJob {\r\n\t//запуск тестового канала событий\r\n\tpublic function run() {\r\n\t\t//инициализация канала событий\r\n\t\t$newsChannel = new EventChannel(); //в нашем случае это новостной канал \r\n\r\n\t\t//подключение канала событий к издателям и создание издателя\r\n\t\t$highgardenGroup = new Publisher('highgarden-news', $newsChannel); //группа новостей хайгардена\r\n\t\t$winterfellNews = new Publisher('winterfell-news', $newsChannel); //группа новостей винтерфелла\r\n\t\t$winterfellDaily = new Publisher('winterfell-news', $newsChannel); //группа новостей альтернативного винтерфелла \r\n\r\n\t\t//создание подписчиков (получателей событий)\r\n\t\t$sansa = new Subscriber('Sansa Stark');\r\n\t\t$arya = new Subscriber('Arya Stark');\r\n\t\t$cersei = new Subscriber('Cersei Lannister');\r\n\t\t$snow = new Subscriber('Jon Snow');\r\n\r\n\t\t//связываем получателя с событием через канал событий\r\n\t\t$newsChannel->subscribe('highgarden-news', $cersei); //серсея подписывается на новости хайгардена\r\n\t\t$newsChannel->subscribe('winterfell-news', $sansa); // санса подписывается на новости винтерфелла\r\n\t\t$newsChannel->subscribe('highgarden-news', $arya); //арья подписывается на новости хайгардена\r\n\t\t$newsChannel->subscribe('winterfell-news', $arya); //а так же винтерфелла\r\n\t\t$newsChannel->subscribe('winterfell-news', $snow); //джон только на винтерфелл \r\n\r\n\t\t//создаём событие у издателя, тем самым все получатели получат уведомление о том что у издателя произошло событие\r\n\t\t//получат уведомление с помощью канала событий, который мы добавляем к издателю\r\n\t\t//т.е. у нас получается 1 канал событий (1 класс), и несколько издателей (несколько классов) в которые мы добавляем тот канал событий\r\n\t\t$highgardenGroup->publish('New highgarden post');\r\n\t\t$winterfellNews->publish('New winterfell post');\r\n\t\t$winterfellDaily->publish('New alternative winterfell post');\r\n\t}\r\n}\r\n\r\n$eventChannelJob = new EventChannelJob();\r\n$eventChannelJob->run();","description":"<strong>Своими словами:</strong>\r\nЕсть событие (event) в классе, а есть получатель события (там где мы хотим отрабатывать что то, оповещать). Получатель после получения события выполняет свой код допустим, вот посредник между ними это Event Channel который является связующим звеном.  \r\n\r\nв общем есть:\r\n- Publisher : издатель, который создаёт контент какой либо\r\n- Subscriber: подписчик на контент\r\n- Event Channel: тот который следит за событиями Publisher и в случае совпадения с группой подписки Subscriber, уведомляет его (посылает событие)\r\n\r\n<hr>\r\n<strong>Статья с википедиа:</strong>\r\nКанал событий (event channel) - фундаментальный шаблон проектирования, используется для\r\nсоздания канала связи и коммуникации через него посредством событий.\r\n\r\nЭтот канал обеспечивает возможность разным издателям публиковать\r\nсобытия и подписчикам, подписывясь на них, получать уведомления.\r\n\r\n<a href=\"https://ru.wikipedia.org/wiki/%D0%9A%D0%B0%D0%BD%D0%B0%D0%BB_%D1%81%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D0%B9_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)\">Ссылка</a>","path":"EventChannel"}},{"title":"Интерфейс (Interface)","data":{"code":"//пример тот же что и из канала событий (коротко, только сам интерфейс)\r\n\r\n//класс который запускает работу канала событий и всё при всё\r\nclass EventChannelJob { //это и есть интерфейс\r\n\t//запуск тестового канала событий\r\n\tpublic function run() {\r\n\t\t//инициализация канала событий\r\n\t\t$newsChannel = new EventChannel(); //в нашем случае это новостной канал \r\n\r\n\t\t//подключение канала событий к издателям и создание издателя\r\n\t\t$highgardenGroup = new Publisher('highgarden-news', $newsChannel); //группа новостей хайгардена\r\n\t\t$winterfellNews = new Publisher('winterfell-news', $newsChannel); //группа новостей винтерфелла\r\n\t\t$winterfellDaily = new Publisher('winterfell-news', $newsChannel); //группа новостей альтернативного винтерфелла \r\n\r\n\t\t//создание подписчиков (получателей событий)\r\n\t\t$sansa = new Subscriber('Sansa Stark');\r\n\t\t$arya = new Subscriber('Arya Stark');\r\n\t\t$cersei = new Subscriber('Cersei Lannister');\r\n\t\t$snow = new Subscriber('Jon Snow');\r\n\r\n\t\t//связываем получателя с событием через канал событий\r\n\t\t$newsChannel->subscribe('highgarden-news', $cersei); //серсея подписывается на новости хайгардена\r\n\t\t$newsChannel->subscribe('winterfell-news', $sansa); // санса подписывается на новости винтерфелла\r\n\t\t$newsChannel->subscribe('highgarden-news', $arya); //арья подписывается на новости хайгардена\r\n\t\t$newsChannel->subscribe('winterfell-news', $arya); //а так же винтерфелла\r\n\t\t$newsChannel->subscribe('winterfell-news', $snow); //джон только на винтерфелл \r\n\r\n\t\t//создаём событие у издателя, тем самым все получатели получат уведомление о том что у издателя произошло событие\r\n\t\t//получат уведомление с помощью канала событий, который мы добавляем к издателю\r\n\t\t//т.е. у нас получается 1 канал событий (1 класс), и несколько издателей (несколько классов) в которые мы добавляем тот канал событий\r\n\t\t$highgardenGroup->publish('New highgarden post');\r\n\t\t$winterfellNews->publish('New winterfell post');\r\n\t\t$winterfellDaily->publish('New alternative winterfell post');\r\n\t}\r\n}\r\n\r\n$eventChannelJob = new EventChannelJob();\r\n$eventChannelJob->run(); //вот тут мы запускаем тот самый рычажок интерфейса, который запускает внутри себя цепочку других классов","description":"<strong>Своими словами:</strong>\r\nИнтерфейс паттерн, это не interface из РНР. Стоит запомнить. Данный паттерн это нечто облегчающее работу классов, он сам по себе класс. Паттерн хранит в себе несколько экземпляров других классов для упрощения вызовов методов и работы. Потянул за рычажок интерфейса, и там внутри уже классы делают необходимую работу. Это как педаль газа в машине, нажал на неё и всё работает под капотом. По данному шаблону работают куча других шаблонов со своими компановками описанных в вики. Интерфейс просто абстрактное понятие других паттернов.\r\n\r\n<hr>\r\n<strong>Статья с википедиа:</strong>\r\n\r\nИнтерфейс (англ. interface) — основной шаблон проектирования, являющийся общим методом для структурирования компьютерных программ для того, чтобы их было проще понять. В общем, интерфейс — это класс, который обеспечивает программисту простой или более программно-специфический способ доступа к другим классам.\r\n\r\nИнтерфейс может содержать набор объектов и обеспечивать простую, высокоуровневую функциональность для программиста (например, Шаблон Фасад); он может обеспечивать более чистый или более специфический способ использования сложных классов («класс-обёртка»); он может использоваться в качестве «клея» между двумя различными API (Шаблон Адаптер); и для многих других целей.\r\n\r\nДругими типами интерфейсных шаблонов являются: Шаблон делегирования, Шаблон компоновщик, и Шаблон мост.\r\n\r\n<a href=\"https://ru.wikipedia.org/wiki/%D0%98%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)\" target=\"_blank\">Ссылка</a>","path":"InterfacePattern"}}]},{"header":"Порождающие шаблоны (Creational)","links":[{"title":"Абстрактная фабрика (Abstract factory)","data":{"code":"//Допустим у нас на сайте необходимо сделать переключение интерфейса (поменять тему)\r\n//Для этого нам необходимо реализовать генератор интерфейса GUI\r\n//Реализация будет через Абстрактную фабрику,  в которой будет:\r\n// 1) инициализация фабрики из семейства фабрик в зависимости от условий в класс инициатор\r\n// 2) Фабрика->сгенерируКнопку->нарисуй();\r\n// 3) Классу инициатора нет разницы какая фабрика будет генерировать интерфейс, класс просто запускает общий метод интерфейса\r\n// 4) Сама же Фабрика порождает семейство классов, и в классах выполняются методы\r\n\r\n\r\n\r\n//КОД:\r\n\r\n//===================интерфейсы для реализации фабрик и семейств=====================\r\n//Интерфейсы общие для семейства классов фабрики\r\ninterface ButtonInterface {\r\n\t//У всех наследуемых классов, должен быть реализован этот метод\r\n\tpublic function draw();\r\n}\r\n\r\ninterface CheckBoxInterface {\r\n\t//У всех наследуемых классов, должен быть реализован этот метод\r\n\tpublic function draw();\r\n}\r\n\r\n//Интерфейс общий для фабрик (Кит, инструментарий)\r\ninterface GuiFactoryInterface {\r\n\t//Говорим какие методы необходимо реализовать в фабриках для работы\r\n\tpublic function buildButton(): ButtonInterface;\r\n\r\n\tpublic function buildCheckBox(): CheckBoxInterface;\r\n}\r\n\r\n\r\n\r\n\r\n//================реализация семейства бутстрапа================\r\nclass ButtonBootstrap implements ButtonInterface {\r\n\tpublic function draw(){ //тут генерация html\r\n\t\techo 'Класс кнопки бутстрапа вернул результат<br>';\r\n\t\treturn __CLASS__;\r\n\t}\r\n}\r\n\r\nclass CheckBoxBootstrap implements CheckBoxInterface {\r\n\tpublic function draw(){ //тут генерация html\r\n\t\techo 'Класс чекбокса бутстрапа вернул результат<br>';\r\n\t\treturn __CLASS__;\r\n\t}\r\n}\r\n\r\n//реализация фабрики бутстрапа\r\nclass BootstrapFactory implements GuiFactoryInterface {\r\n \tpublic function buildButton(): ButtonInterface {\r\n \t\techo 'Фабрика Бутстрап создал класс кнопки<br>';\r\n \t\treturn new ButtonBootstrap();\r\n \t}\r\n\r\n \tpublic function buildCheckBox(): CheckBoxInterface {\r\n \t\techo 'Фабрика Бутстрап создал класс чекбокса<br>';\r\n \t\treturn new CheckBoxBootstrap();\r\n \t}\r\n}\r\n\r\n\r\n\r\n\r\n//======================реализация семейства симантика===================\r\nclass ButtonSemanticUi implements ButtonInterface {\r\n\tpublic function draw(){ //тут генерация html\r\n\t\techo 'Класс кнопки семантика вернул результат<br>';\r\n\t\treturn __CLASS__;\r\n\t}\r\n}\r\n\r\nclass CheckBoxSemanticUi implements CheckBoxInterface {\r\n\tpublic function draw(){ //тут генерация html\r\n\t\techo 'Класс чекбокса семантика вернул результат<br>';\r\n\t\treturn __CLASS__;\r\n\t}\r\n}\r\n//реализация фабрики семантика\r\nclass SemanticUiFactory implements GuiFactoryInterface {\r\n\tpublic function buildButton(): ButtonInterface {\r\n\t\techo 'Семантик создал класс кнопки<br>';\r\n\t\treturn new ButtonSemanticUi();\r\n \t}\r\n\r\n \tpublic function buildCheckBox(): CheckBoxInterface {\r\n \t\techo 'Семантик создал класс чекбокса<br>';\r\n \t\treturn new CheckBoxSemanticUi();\r\n \t}\r\n}\r\n\r\n\r\n\r\n\r\n\r\n//==============================Переключатель фабрик==================\r\nclass GuiKitFactory  {\r\n\r\n\t/**\r\n\t * Create Abstract Factory\r\n\t * @param  [string] $type [factory name]\r\n\t * @return [GuiFactoryInterface]       [Factory]\r\n\t */\r\n\tpublic function getFactory($type): GuiFactoryInterface {\r\n\t\t$factory;\r\n\r\n\t\tswitch ($type) {\r\n\t\t\tcase 'bootstrap': {\r\n\t\t\t\techo 'Инициализация фабрики Bootstrap<br>';\r\n\t\t\t\t$factory = new BootstrapFactory();\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase 'semanticui' : {\r\n\t\t\t\techo 'Инициализация фабрики Semantic<br>';\r\n\t\t\t\t$factory = new SemanticUiFactory();\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tdefault: {\r\n\t\t\t\texit(\"Неизвестный тип фабрики [{$type}]<br>\");\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn $factory;\r\n\t}\r\n\r\n\tpublic static function getDescription(){\r\n\t\treturn 1;\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n//=====================запуск====================\r\nclass ExampleClass {\r\n\r\n\t/**\r\n\t * Переключалка между фабриками\r\n\t * @var [GuiFactoryInterface]\r\n\t */\r\n\tprivate $guiKit;\r\n\r\n\tpublic function __construct(){\r\n\t\t//изначально выставляем фабрику bootstrap\r\n\t\t$this->guiKit = (new GuiKitFactory())->getFactory('bootstrap');\r\n\t\t//$this->guiKit = (new GuiKitFactory())->getFactory('semanticui');\r\n\t}\r\n\r\n\r\n\tpublic function AbstractFactory(){\r\n\t\t$name = 'Абстрактная фабрика';\r\n\t\t$description = GuiKitFactory::getDescription();\r\n\r\n\t\t//фабрика генерирует кнопку и чекбокс \r\n\t\t$result[] = $this->guiKit->buildButton()->draw();\r\n\t\t$result[] = $this->guiKit->buildCheckBox()->draw();\r\n\r\n\t\tvar_dump($description);\r\n\t\tvar_dump($result);\r\n\t}\r\n}\r\n\r\n$test = new ExampleClass();\r\n$test->AbstractFactory();","description":"<strong>Своими словами:</strong>\r\nАбстрактная фабрика это такой класс который может порождать внутри себя несколько классов которые наследуются по какому либо одному интерфейсу, так же сами фабрики могут наследоваться от одного интерфейса. \r\n\r\nВ абстрактной фабрике может быть несколько семейств порождённых классов, но они никак не должны контактировать друг с другом. Например семейство классов ClassA и семейство классов ClassB наследуются от одного интерфейса. Реализация у всех разная, но методы наследуемые от интерфейса одинаковые.\r\n\r\nТак же самих Абстрактных фабрик может быть несколько, они так же должны быть наследованы от одного семейства (интерфейса) и не должны контактировать друг с другом. Например ClassFactoryA и ClassFactoryB наследуются от одного интерфейса. Реализация у всех разная, но методы наследуемые от интерфейса одинаковые.\r\n\r\nДля нескольких фабрик одного семейства необходимо реализовать класс который умеет переключать эти фабрики в зависимости от условий. Т.к. интерфейс общий, то и выходящие методы тоже общие. А значит переключение будет безболезненным. \r\n\r\n<hr>\r\n<strong>Статья с refactoring.guru:</strong>\r\n\r\nАбстрактная фабрика — это порождающий паттерн проектирования, который позволяет создавать семейства связанных объектов, не привязываясь к конкретным классам создаваемых объектов.\r\n\r\n<a href=\"https://refactoring.guru/ru/design-patterns/abstract-factory\" target=\"_blank\">Ссылка</a>\r\n\r\n<a href=\"https://refactoring.guru/ru/design-patterns/factory-comparison\" target=\"_blank\">Ссылка на сравнение фабрик</a>\r\n\r\n<hr>\r\n<strong>Статья с википедиа:</strong>\r\nАбстрактная фабрика (англ. Abstract factory) — порождающий шаблон проектирования, предоставляет интерфейс для создания семейств взаимосвязанных или взаимозависимых объектов, не специфицируя их конкретных классов. Шаблон реализуется созданием абстрактного класса Factory, который представляет собой интерфейс для создания компонентов системы (например, для оконного интерфейса он может создавать окна и кнопки). Затем пишутся классы, реализующие этот интерфейс[2].\r\n\r\n<a href=\"https://ru.wikipedia.org/wiki/%D0%90%D0%B1%D1%81%D1%82%D1%80%D0%B0%D0%BA%D1%82%D0%BD%D0%B0%D1%8F_%D1%84%D0%B0%D0%B1%D1%80%D0%B8%D0%BA%D0%B0_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)\" target=\"_blank\">Ссылка</a>","path":"AbstractFactory"}},{"title":"Фабричный метод (Factory Method)","data":{"code":"//Допустим у нас на сайте необходимо сделать переключение интерфейса (поменять тему)\r\n//Для этого нам необходимо реализовать генератор интерфейса GUI\r\n//Реализация будет через Фабричный метод,  в котором будет:\r\n// 1) Инициализация дочернего класса наследуюемого от суперкласса \r\n// 2) Дочерний класс вызывает метод суперкласса генерации: дочерний->рендер();\r\n// 3) Суперкласс в свою очередь вызывает метод дочернего для пораждения фабрики  получитьФабрику();\r\n// 4) Дочерний пораждает фабрику и возвращает суперклассу\r\n// 5) Суперкласс реализовывает механику пораждённой фабрики внутри себя\r\n// Т.е. у нас получается все дочерние классы могут порождать разные фабрики, и все они будут ссылаться на суперкласс, который реализует механику\r\n\r\n/**\r\n * Интерфейс фабричного метода, для реализации методов в дочерних элементах\r\n */\r\ninterface FormInterface {\r\n\tpublic function render();\r\n\r\n\tfunction createGuiKit(): GuiFactoryInterface;\r\n}\r\n\r\n\r\n\r\n//===================интерфейсы для реализации фабрик и семейств=====================\r\n//Интерфейсы общие для семейства классов фабрики\r\ninterface ButtonInterface {\r\n\t//У всех наследуемых классов, должен быть реализован этот метод\r\n\tpublic function draw();\r\n}\r\n\r\ninterface CheckBoxInterface {\r\n\t//У всех наследуемых классов, должен быть реализован этот метод\r\n\tpublic function draw();\r\n}\r\n\r\n//Интерфейс общий для фабрик (Кит, инструментарий)\r\ninterface GuiFactoryInterface {\r\n\t//Говорим какие методы необходимо реализовать в фабриках для работы\r\n\tpublic function buildButton(): ButtonInterface;\r\n\r\n\tpublic function buildCheckBox(): CheckBoxInterface;\r\n}\r\n\r\n\r\n\r\n//================реализация семейства бутстрапа================\r\nclass ButtonBootstrap implements ButtonInterface {\r\n\tpublic function draw(){ //тут генерация html\r\n\t\techo 'Класс кнопки бутстрапа вернул результат<br>';\r\n\t\treturn __CLASS__;\r\n\t}\r\n}\r\n\r\nclass CheckBoxBootstrap implements CheckBoxInterface {\r\n\tpublic function draw(){ //тут генерация html\r\n\t\techo 'Класс чекбокса бутстрапа вернул результат<br>';\r\n\t\treturn __CLASS__;\r\n\t}\r\n}\r\n\r\n//реализация фабрики бутстрапа\r\nclass BootstrapFactory implements GuiFactoryInterface {\r\n \tpublic function buildButton(): ButtonInterface {\r\n \t\techo 'Фабрика Бутстрап создал класс кнопки<br>';\r\n \t\treturn new ButtonBootstrap();\r\n \t}\r\n\r\n \tpublic function buildCheckBox(): CheckBoxInterface {\r\n \t\techo 'Фабрика Бутстрап создал класс чекбокса<br>';\r\n \t\treturn new CheckBoxBootstrap();\r\n \t}\r\n}\r\n\r\n\r\n\r\n\r\n//======================реализация семейства симантика===================\r\nclass ButtonSemanticUi implements ButtonInterface {\r\n\tpublic function draw(){ //тут генерация html\r\n\t\techo 'Класс кнопки семантика вернул результат<br>';\r\n\t\treturn __CLASS__;\r\n\t}\r\n}\r\n\r\nclass CheckBoxSemanticUi implements CheckBoxInterface {\r\n\tpublic function draw(){ //тут генерация html\r\n\t\techo 'Класс чекбокса семантика вернул результат<br>';\r\n\t\treturn __CLASS__;\r\n\t}\r\n}\r\n//реализация фабрики семантика\r\nclass SemanticUiFactory implements GuiFactoryInterface {\r\n\tpublic function buildButton(): ButtonInterface {\r\n\t\techo 'Семантик создал класс кнопки<br>';\r\n\t\treturn new ButtonSemanticUi();\r\n \t}\r\n\r\n \tpublic function buildCheckBox(): CheckBoxInterface {\r\n \t\techo 'Семантик создал класс чекбокса<br>';\r\n \t\treturn new CheckBoxSemanticUi();\r\n \t}\r\n}\r\n\r\n\r\n//======================реализация фабричного метода===================\r\n/**\r\n * допустим абстрактная форма генерирующая диалоговое окно\r\n *\r\n * суперкласс который реализовывает в себе механики работы фабрик дочерних классов\r\n */\r\nabstract class AbstractForm implements FormInterface {\r\n\t\r\n\t/**\r\n\t * В абстрактном классе есть логика генерации формы\r\n\t * реализация фабрики\r\n\t * @return [mixed] [result]\r\n\t */\r\n\tpublic function render(){\r\n\r\n\t\t$guiKit = $this->createGuiKit(); //получить некий инструментарий для отрисовки  \r\n\t\t$name = get_class($guiKit);\r\n\t\techo \"Суперкласс реализовывает механику работы от дочернего класса [{$name}]<br>\";\r\n\t\t//сгенерировать GUI формы\r\n\t\t$result[] = $guiKit->buildCheckBox()->draw();\r\n\t\t$result[] = $guiKit->buildButton()->draw();\r\n\r\n\t\treturn $result;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Получаем инструментарий (фабрику) для рисования объектов формы \r\n\t * данный метод должен быть реализован в наследуемых классах\r\n\t * @return [GuiFactoryInterface] [инструментарий (фабрика)]\r\n\t */\r\n\tabstract function createGuiKit(): GuiFactoryInterface;\r\n}\r\n\r\n\r\n/**\r\n * В наследуюемом классе реализуем пораждение инструментария \r\n * для возврата в абстрактную фабрику для работы\r\n */\r\nclass BootstrapDialogForm extends AbstractForm {\r\n\t/**\r\n\t * Дочерний элемент создаёт инструментарий (фабрику)\r\n\t * @return [GuiFactoryInterface] [Инструментарий]\r\n\t */\r\n\tpublic function createGuiKit(): GuiFactoryInterface {\r\n\t\techo \"Дочерний класс порадил фабрику BootStrap<br>\";\r\n\t\treturn new BootstrapFactory();\r\n\t}\r\n}\r\n\r\n/**\r\n * В наследуюемом классе реализуем пораждение инструментария \r\n * для возврата в абстрактную фабрику для работы\r\n */\r\nclass SemanticUiDialogForm extends AbstractForm {\r\n\t/**\r\n\t * Дочерний элемент создаёт инструментарий (фабрику)\r\n\t * @return [GuiFactoryInterface] [Инструментарий]\r\n\t */\r\n\tpublic function createGuiKit(): GuiFactoryInterface {\r\n\t\techo \"Дочерний класс порадил фабрику Semantic<br>\";\r\n\t\treturn new SemanticUiFactory();\r\n\t}\r\n}\r\n\r\n\r\n//=====================запуск====================\r\n\r\nclass ExampleClass {\r\n\tpublic function FactoryMethod() {\r\n\t\t$name = 'Фабричный метод';\r\n\t\t//создание фабричного инструментария\r\n\t\t$dialogForm = new BootstrapDialogForm();\r\n\t\t//$dialogForm = new SemanticUiDialogForm();\r\n\t\t//вызов реализации механики работы фабрики из абстрактного класса\r\n\t\t$result = $dialogForm->render();\r\n\t\tvar_dump($result);\r\n\t}\r\n}\r\n\r\n$test = new ExampleClass();\r\n$test->FactoryMethod();\r\n","description":"<strong>Cвоими словами: </strong>\r\nФабричный метод подразумевает основную механику работы с фабриками внутри абстрактного суперкласса. \r\n\r\n!Т.е. у нас есть суперкласс и есть дочерние классы которые наследованы от него. \r\nМы не можем породить суперкласс т.к. он абстрактный, мы можем породить только дочерние классы, и от дочернего будет работать суперкласс. \r\nВсе дочерние классы (наследованные от суперкласса) могут порождать разные фабрики вернув их в суперкласс,  который в свою очередь реализует механику работы этих фабрик.\r\n\r\n<hr>\r\n<strong>Статья с refactoring.guru: </strong>\r\nФабричный метод — это порождающий паттерн проектирования, который определяет общий интерфейс для создания объектов в суперклассе, позволяя подклассам изменять тип создаваемых объектов.\r\n\r\n<a href=\"https://refactoring.guru/ru/design-patterns/factory-method\" target=\"_blank\">Ссылка</a>\r\n\r\n<hr>\r\n<strong>Статья с википедиа: </strong>\r\nФабричный метод (англ. Factory Method), или виртуальный конструктор (англ. Virtual Constructor) — порождающий шаблон проектирования, предоставляющий подклассам (дочерним классам) интерфейс для создания экземпляров некоторого класса. В момент создания наследники могут определить, какой класс создавать. Иными словами, данный шаблон делегирует создание объектов наследникам родительского класса. Это позволяет использовать в коде программы не специфические классы, а манипулировать абстрактными объектами на более высоком уровне.\r\n\r\n<a href=\"https://ru.wikipedia.org/wiki/%D0%A4%D0%B0%D0%B1%D1%80%D0%B8%D1%87%D0%BD%D1%8B%D0%B9_%D0%BC%D0%B5%D1%82%D0%BE%D0%B4_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)\" target=\"_blank\">Ссылка</a>","path":"Factory Method"}},{"title":"Статическая фабрика (Static factory)","data":{"code":"//будем использовать один из шаблонов проектирование (Delegation) и обернём его статической фабрикой\r\n//интерфейс делегирования\r\ninterface MessengerInterface {\r\n\t//установить отправителя\r\n\tpublic function setSender($value): MessengerInterface;\r\n\r\n\t//установить получателя\r\n\tpublic function setRecipient($value): MessengerInterface;\r\n\r\n\t//установить сообщение\r\n\tpublic function setMessage($value): MessengerInterface;\r\n\r\n\t//отправить сообщение\r\n\tpublic function send():bool; \r\n}\r\n\r\n//интерфейс статической фабрики\r\ninterface StaticFactoryInterface {\r\n\t/**\r\n\t * Фабрика должна реализовать методы данного интерфейса\r\n\t * @param  [string] $type [наименование класса]\r\n\t * @return [mixed]       [object]\r\n\t */\r\n\tpublic static function build($type);\r\n}\r\n\r\n//Абстрактный класс, который реализовывает базовые методы интерфейса\r\n//последующие классы наследуются от абстрактного класса, для дальнейшей реализации\r\nabstract class AbstractMessenger implements MessengerInterface {\r\n\tprotected $sender; //отправитель\r\n\r\n\tprotected $recipient; //получатель\r\n\r\n\tprotected $message; //сообщение \r\n\r\n\t//установить отправителя\r\n\tpublic function setSender($value) : MessengerInterface\r\n\t{\r\n\t\t$this->sender = $value;\r\n\t\treturn $this;\r\n\t}\r\n\r\n\t//установить получателя\r\n\tpublic function setRecipient($value): MessengerInterface\r\n\t{\r\n\t\t$this->recipient = $value;\r\n\t\treturn $this;\r\n\t}\r\n\r\n\tpublic function setMessage($value): MessengerInterface\r\n\t{\r\n\t\t$this->message = $value;\r\n\t\treturn $this;\r\n\t}\r\n\r\n\t//отправить сообщение\r\n\tpublic function send(): bool \r\n\t{\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\n//т.к. мы наследуемся от абстрактного класса, то метод send() будет перегружен,\r\n//поэтому, мы отправляем сенд на абстрактный класс через parrent\r\n//\r\nclass EmailMessenger extends AbstractMessenger {\r\n\t//тут много кода по реализации отправки по email\r\n\tpublic function send(): bool \r\n\t{\r\n\t\t//тут код отправки\r\n\t\techo 'Send by Email<br>';\r\n\t\treturn parent::send(); //отправляем из абстрактного класса\r\n\t}\r\n}\r\n\r\nclass SmsMessenger extends AbstractMessenger {\r\n\t//тут много кода реализации отправки по СМС\r\n\tpublic function send(): bool \r\n\t{\r\n\t\t//тут код отправки\r\n\t\techo 'Send by SMS<br>';\r\n\t\treturn parent::send(); //отправляем из абстрактного класса\r\n\t}\r\n}\r\n\r\n//сам класс который будет делегировать \r\nclass AppMessenger implements MessengerInterface {\r\n\t\r\n\t//приватное свойство messenger, это тот, на кого мы будем делегировать работу (экземпляр класса)\r\n\tprivate $messenger; \r\n\r\n\tpublic function __construct(){\r\n\t\t//по дефолту вызывем метод toEmail где у нас создаётся класс EmailMessenger и присваивается в messenger переменную\r\n\t\t//это нужно чтоб ничто не сломалось\r\n\t\t$this->toEmail(); \r\n\t}\r\n\r\n\tstatic public function getDescription() {\r\n\r\n\t}\r\n\r\n\t//если по email, то вернём экземпляр класса \r\n\t//EmailMessenger и ещё присвоим его в переменную messenger\r\n\tpublic function toEmail(){ \r\n\t\t$this->messenger = new EmailMessenger();\r\n\t\treturn $this;\r\n\t}\r\n\r\n\r\n\t//если по sms, то вернём экземпляр класса\r\n\t//SmsMessenger и ещё присвоим его в переменную messenger\r\n\tpublic function toSMS(){\r\n\t\t//т.к. у нас изначально toEmail, то тут мы просто перезапишем в messenger новый экземпляр класса SmsMessenger\r\n\t\t$this->messenger = new SmsMessenger();\r\n\t\treturn $this;\r\n\t}\r\n\r\n\t//т.к. у нас данный класс так же наследуется от интерфейса, то нам необходимо реализовать его методы\r\n\tpublic function setSender($value): MessengerInterface { //обязательно возвращаемый у нас будет MessengerInterface\r\n\t\t$this->messenger->setSender($value); //но тут мы будем делегировать методы в тот класс, который породили в messenger\r\n\t\treturn $this->messenger;\r\n\t}\r\n\r\n\t//т.к. у нас данный класс так же наследуется от интерфейса, то нам необходимо реализовать его методы\r\n\tpublic function setRecipient($value): MessengerInterface { //обязательно возвращаемый у нас будет MessengerInterface\r\n\t\t$this->messenger->setRecipient($value); //но тут мы будем делегировать методы в тот класс, который породили в messenger\r\n\t\treturn $this->messenger;\r\n\t}\r\n\t\r\n\t//т.к. у нас данный класс так же наследуется от интерфейса, то нам необходимо реализовать его методы\r\n\tpublic function setMessage($value): MessengerInterface {\r\n\t\t$this->messenger->setMessage($value); //но тут мы будем делегировать методы в тот класс, который породили в messenger\r\n\t\treturn $this->messenger;\r\n\t}\r\n\r\n\r\n\t//т.к. у нас данный класс так же наследуется от интерфейса, то нам необходимо реализовать его методы\r\n\tpublic function send(): bool {\r\n\t\treturn $this->messenger->send(); //но тут мы будем делегировать методы в тот класс, который породили в messenger\r\n\t}\r\n\r\n}\r\n\r\n//реализация статической фабрики\r\n\r\nclass StaticFactory implements StaticFactoryInterface {\r\n\tpublic static function build($type = 'email') {\r\n\t\t$item = new AppMessenger();\r\n\t\tswitch($type) {\r\n\t\t\tcase 'email' : {\r\n\t\t\t\t$item->toEmail()\r\n\t\t\t\t->setSender('Default Sender')\r\n\t\t\t\t->setRecipient('default@example.com');\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase 'sms' : {\r\n\t\t\t\t$item->toSms()\r\n\t\t\t\t->setSender('Default Sender')\r\n\t\t\t\t->setRecipient('8888888888');\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tdefault:{\r\n\t\t\t\tthrow new Exception(\"Invalid type [{$type}]\", 1);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\t$item->setMessage('Default message');\r\n\t\treturn $item;\r\n\t}\r\n}\r\n\r\n//применение:\r\n$sendEmail = StaticFactory::build('email');\r\n$sendSMS = StaticFactory::build('sms');\r\n\r\n$sendEmail->send();\r\nvar_dump($sendEmail, $sendSMS);","description":"<strong>Своими словами:</strong>\r\nСтатическая фабрика это некий вид простой фабрики, которая порождает объекты (экземпляры классов) с помощью статического метода и делает базовые настройки данного объекта. Т.е. у нас есть класс фабрики (StaticFactory) и в нём есть статический метод (public static build()), и там уже в параметрах выставляется какой объект нужно породить.\r\n\r\n<strong>Остальные объяснения:</strong>\r\nВ интернете нет чёткого представления по этой фабрике. Поэтому делаем так как поняли сами.","path":"Static factory"}},{"title":"Простая фабрика (Simple factory)","data":{"code":"//будем использовать один из шаблонов проектирование (Delegation) и обернём его простой фабрикой\r\n//интерфейс делегирования\r\ninterface MessengerInterface {\r\n\t//установить отправителя\r\n\tpublic function setSender($value): MessengerInterface;\r\n\r\n\t//установить получателя\r\n\tpublic function setRecipient($value): MessengerInterface;\r\n\r\n\t//установить сообщение\r\n\tpublic function setMessage($value): MessengerInterface;\r\n\r\n\t//отправить сообщение\r\n\tpublic function send():bool; \r\n}\r\n\r\n//интерфейс статической фабрики\r\ninterface SimpleFactoryInterface {\r\n\t/**\r\n\t * Фабрика должна реализовать методы данного интерфейса\r\n\t * @param  [string] $type [наименование класса]\r\n\t * @return [mixed]       [object]\r\n\t */\r\n\tpublic  function build($type);\r\n}\r\n\r\n//Абстрактный класс, который реализовывает базовые методы интерфейса\r\n//последующие классы наследуются от абстрактного класса, для дальнейшей реализации\r\nabstract class AbstractMessenger implements MessengerInterface {\r\n\tprotected $sender; //отправитель\r\n\r\n\tprotected $recipient; //получатель\r\n\r\n\tprotected $message; //сообщение \r\n\r\n\t//установить отправителя\r\n\tpublic function setSender($value) : MessengerInterface\r\n\t{\r\n\t\t$this->sender = $value;\r\n\t\treturn $this;\r\n\t}\r\n\r\n\t//установить получателя\r\n\tpublic function setRecipient($value): MessengerInterface\r\n\t{\r\n\t\t$this->recipient = $value;\r\n\t\treturn $this;\r\n\t}\r\n\r\n\tpublic function setMessage($value): MessengerInterface\r\n\t{\r\n\t\t$this->message = $value;\r\n\t\treturn $this;\r\n\t}\r\n\r\n\t//отправить сообщение\r\n\tpublic function send(): bool \r\n\t{\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\n//т.к. мы наследуемся от абстрактного класса, то метод send() будет перегружен,\r\n//поэтому, мы отправляем сенд на абстрактный класс через parrent\r\n//\r\nclass EmailMessenger extends AbstractMessenger {\r\n\t//тут много кода по реализации отправки по email\r\n\tpublic function send(): bool \r\n\t{\r\n\t\t//тут код отправки\r\n\t\techo 'Send by Email<br>';\r\n\t\treturn parent::send(); //отправляем из абстрактного класса\r\n\t}\r\n}\r\n\r\nclass SmsMessenger extends AbstractMessenger {\r\n\t//тут много кода реализации отправки по СМС\r\n\tpublic function send(): bool \r\n\t{\r\n\t\t//тут код отправки\r\n\t\techo 'Send by SMS<br>';\r\n\t\treturn parent::send(); //отправляем из абстрактного класса\r\n\t}\r\n}\r\n\r\n//реализация простой фабрики\r\n\r\nclass SimpleFactory implements SimpleFactoryInterface {\r\n\tpublic function build($type = 'email') {\r\n\t\t$item;\r\n\t\tswitch($type) {\r\n\t\t\tcase 'email' : {\r\n\t\t\t\t$item = new EmailMessenger();\r\n\t\t\t\t$item\r\n\t\t\t\t->setSender('Default Sender')\r\n\t\t\t\t->setRecipient('default@example.com');\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase 'sms' : {\r\n\t\t\t\t$item = new SmsMessenger();\r\n\t\t\t\t$item\r\n\t\t\t\t->setSender('Default Sender')\r\n\t\t\t\t->setRecipient('8888888888');\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tdefault:{\r\n\t\t\t\tthrow new Exception(\"Invalid type [{$type}]\", 1);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\t$item->setMessage('Default message');\r\n\t\treturn $item;\r\n\t}\r\n}\r\n\r\n//применение:\r\n$factoryMessenger = new SimpleFactory();\r\n$sendEmail = $factoryMessenger->build('email');\r\n$sendSMS = $factoryMessenger->build('sms');\r\n\r\n$sendEmail->send();\r\nvar_dump($sendEmail, $sendSMS);","description":"<strong>Своими словами:</strong>\r\nПримерно то же что и статическая фабрика, только метод build не статический. Данную фабрику нужно породить чтоб была возможность использования метода build. Сам метод build отличается от static factory тем что в каждом условии выбора создаётся свой класс, а не общий для классов. \r\n\r\n<hr>\r\n<strong>Статья с refactoring.guru:</strong>\r\nПаттерн Простая фабрика  — это класс, в котором есть один метод с большим условным оператором, выбирающим создаваемый продукт. Этот метод вызывают с неким параметром, по которому определяется какой из продуктов нужно создать. У простой фабрики, обычно, нет подклассов.\r\n\r\n<a href=\"https://refactoring.guru/ru/design-patterns/factory-comparison\" target=\"_blank\">Ссылка</a>","path":"Simple Factory"}}]},{"header":"Структурные шаблоны (Structural)"},{"header":"Поведенческие шаблоны (Behavioral)"},{"header":"Свои наработки других ЯП (Other)","links":[{"title":"SCRUM","data":{"code":"Кода нет","description":"SCRUM\r\nВ нём есть роли главные:\r\n1) Клиент - тот кто предлагает идею и имеет деньги\r\n2) Продукт овнер - тот кто занимается комуникацией клиента и ведёт проект по его логической составляющей \r\nесть продукт овнеры со стороны кодеров и отдельные наёмные со стороны клиента. Решается от заказа.\r\n3) Бизнес аналитик - непосредственно работает с продукт овнером, связующее звяно продукт оврена и кодеров \r\nПеревод из клиентского языка в кодерский, создаёт бэклог.\r\n\r\nДалее виды задач в скраме: \r\n1) Бэклог - перечень задач для выполнения более абстрактный, общий\r\n2) Эпик - как раз составляющая бэклога, они масштабные (большая задача функционала)\r\nНапример при создании соц сетей нужно 2 эпика, первый эпик площадка общения пользователей, \r\nвторой эпик B2B площадка для скупки статистики компаниями \r\nВот это 2 эпика, а общее это бэклог \r\n3) Стори/Сторис - берём эпик и разбиваем (кодеры разбивают) на более мелкие задачи логические \r\nЭто ещё не задача для разработки, это наборосок для последующего разделения на \r\nконкретные задачи. Например: \r\nЛК пользователя должен состоять из функционала авторизации, функционала рассылки уведомлений, функционала по обмену сообщений между пользователями\r\n4) Такс/Задача - вот это сама задача непосредственно для кодера. Вот тут кодеры и работают.\r\n\r\nВ общем, бэклог это не просто список задач это список приоритезированный,\r\nтут бизнес аналитик и продукт овнер решает, какая задача должна быть реализована намного раньше. Выставление приоритетов.\r\n\r\nВ SCRUM имеются собрания, и они называются по разному. Планинг покер, оценка задач и т.п. \r\nБерётся стори и разбивается на таски/задачи.\r\nПланинг покер - это вытавление стори поинтов на определённый стори поинт. \r\nСтори поинт это такая величина, которая определяется сложностью выполнения задачи. \r\nДля определения стори поинта, находится эталон поинта. Допустим эталон - создать регистрацию.\r\nИ каждый кодер выставляет свой поинт - сколько примерно он бы дал за него. \r\nДалее выбирается средняя величина - она и есть эталон стори поинтов. Допустим Рега 10.\r\nДалее в планинг покере берётся стори и оценивается отталкиваясь от эталона. \r\nДопустим: стори - создать личный кабинет. \r\nКодеры в закрытую выставляют свои стори поинты. После чего показывают, сколько они дали на эту стори поинтов.\r\nЕсли показания очень разнятся, то берётся самый минимальный и максимальный поинт, и просят прокомментировать,\r\nпочему они так выставили. И после чего проводится ещё одно голосование. После этого голосования,\r\nесли все вердикты примерно одинаковые - то берётся поинт за эту задачу. Если опять разнятся, то берётся\r\nсредне арифметическое по всем поинтам, и начинается разбиение стори на таски.\r\nПосле стори обсуждаются таски, там так же выполняется голосование, сколько времени займёт тот или иной таск.\r\nКоротко: берём стори - оцениваем по поинтам, разбиваем стори на таски и оцениваем по времени.\r\nНа этих собраниях выставляются ответственные за ту или иную стори. \r\nПосле всех этих танцев с бубном уже есть готовый ToDo List для выполнения. \r\n\r\nПосле собрания и ToDo List'а. Спринт считается запущенным по этому стори.\r\nСпринт - это тот промежуток времени, за который должны успеть выполнить ту или иную часть продукта или готовый продукт.\r\nЕстественно отталкиваясь от голосования. Спринты определяются кратными неделями 1,2,3,4 недели.\r\nОпределяется началом от планинг покера и концом (ревью, или презентация продукта заказчику своих задач).\r\nВажно что в конце спринта есть работоспособная система.\r\n\r\nВ рамках спринта стори имеет разные статусы:\r\n1) ToDo - стори выставлена после оценки сюда\r\n2) InProgress - разраб взял себе в разработку эту сторю \r\n3) ReadyForQA - стори выполнена, и нуждается в тестировании QA\r\n3.3) Если QA нашёл ошибку, то он может отправить её обратно в InProgress\r\n     или же отправляет в статус Rejected (между ToDo и InProgress, означает приоритетная очередь решения задачи)\r\n4) Done - после QA, если багов нет или пофиксены, стори выполнена. \r\n5) Всё, story закрыта (стори). Все таски стори готовы и выполнены, спринт завершён.\r\n6) Ревью, показать заказчику всё работает, всё круто, мы крутые, а вы платите деньги.\r\n7) Ретроспектива - собрание \r\n\tТут обсуждаются положительные и отрицательные моменты в спринте.\r\n\tИ что делать в следующих спринтах, что бы улучшить их.\r\n\tКаждый предлагает свои идеи (если есть)\r\n\r\n\tЧем короче спринт, тем легче внести изменения в существующий скрам. \r\n\tЗаказчик не в праве прям на ходу изменять всё. Только в следующим спринту. \r\n\tСпринты обычно делаются 2х недельные.\r\n8) Эффективность команды - берутся стори поинты от команды которая делала ту или иную стори, суммируется, \r\nи определяется какая команда лучше всего набила эти поинты. Значит она самая эффективная. \r\n\r\nЕсть ещё скраммастер - тот кто за всем следит, чтоб вся система работала. Пастух наблюдатель хехе )\r\nОбычно это делает менеджер проекта.\r\nSCRUM рассчитан на команду из 5 и максимум из 9 разрабов. \r\n\r\n\r\n\r\n \r\n","path":"Методология разработки"}}]},{"header":"JavaScript основы","links":[{"title":"Типы данных и динамическая типизация","data":{"code":"//Примеры:\r\nconst n = 123; // nubmer\r\nconst s = \"Hello\"; // string\r\nconst b = false; // bool\r\nconst u; // undefined\r\nconst na = 123 * \"Hello world\"; // NaN","description":"В JavaScript существует несколько типов данных. Тип данных инициализируется во время первичного присваивания какого либо значения.\r\n\r\nТипы данных:\r\nnumber - числовой тип данных, хранит в себе любые значения состоящие из чисел 123\r\nbool - булевый тип данных, хранит в себе данные вида истина/ложь - true/false - 1/0\r\nstring - хранит в себе любые строки 'привет мир', \"Привет мир\", `Привет мир`\r\nundefined - означает что значения в переменной нет\r\nnull - неопределённое значение, никакое значение из вышеперечисленных \r\nNaN - is non a number, появляется при попытке выполнить математические операции между типами данных, которые не подразумевают их. Допустим 'A' * 3; \r\n\r\nВсе типы данных основаны на Object \r\n\r\n\r\n","path":"Типы данных и динамическая типизация"}},{"title":"Объекты и массивы","data":{"code":"//Примеры\r\nlet obj = {\r\nname: 'foo',\r\nsurname: 'bar'\r\n};\r\n\r\nlet arr = ['foo', 'bar'];\r\nlet objArr = {0: 'Значение 1', 1: 'Значение 2', 2: 'Значение 3', length: 3};\r\n\r\n\r\n//Методы и объекты внутри объекта\r\nconst obj = {\r\n    name: 'test',\r\n    width: 1024,\r\n    height: 768,\r\n    colors: {\r\n        border: 'black',\r\n        bg: 'red',\r\n    },\r\n    makeTest: function () {\r\n        console.log(\"test\");\r\n    }\r\n};\r\n\r\n\r\n//работа с массивами\r\nconst arrTest = [1, 2, 3, 4];\r\narrTest.pop(); //удалить последний элемент массива\r\nconsole.log(arrTest);\r\narrTest.push(5); //добавить элемент в конец\r\nconsole.log(arrTest);\r\n\r\nconst intArr = [1, 2, 44, 5, 18];\r\nfunction compareNum(a, b) {\r\n    return a - b;\r\n}\r\nintArr.sort(compareNum); //сортировать по int через калбэк\r\nconsole.log(intArr);\r\n\r\n\r\n//Объект создаётся один (экземпляр), и мы через переменные указываем на них (указатель). \r\n//Тем самым мы не можем просто так сделать на подобии обычных переменных\r\nlet obj1 = {\r\na: 'foo',\r\nb: 'bar'\r\n};\r\nlet obj2 = obj1; //у нас 2 переменные будут ссылаться на 1 экземпляр объекта, и если мы из obj1 что то изменим, то изменится и в obj2\r\n\r\n//для этого есть spread оператор, это такой оператор короче гуглите (коротко выдаёт всё что есть в объекте/массиве)\r\nconst obj1 = {\r\n    one: 1,\r\n    two: 2,\r\n    tree: 3\r\n};\r\n\r\nconst obj2 = {\r\n    ...obj1,  //развернули объект и вставили данные из него в новый объект\r\n}\r\nobj2.one = 4;\r\nconsole.log(obj1);\r\nconsole.log(obj2);\r\n\r\n\r\n//Деструктуризация объекта\r\nconst obj = {\r\na: 'foo',\r\nb: 'bar',\r\ncolors: {\r\n    border: '2px',\r\n     bg: 'red'\r\n  }\r\n};\r\nconst { border, bg } = obj.colors; //деструктуризация, получить вложенные данные из объекта в переменные \r\nconsole.log(bg);\r\n\r\nconst obj = {\r\n    name: 'test',\r\n    width: 1024,\r\n    height: 768,\r\n    colors: {\r\n        border: 'black',\r\n        bg: 'red',\r\n    },\r\n    makeTest: function () {\r\n        console.log(\"test\");\r\n    }\r\n};\r\n\r\n//удаление из объекта\r\ndelete obj.name; //удаляет свойство и значение из объекта\r\n\r\n//получение ключей объекта\r\nconsole.log(Object.keys(obj)); //получить все ключи объекта в виде массива\r\n\r\n//перебор объекта\r\nfor(let key in obj) {\r\n     console.log(`Свойство: ${key} \\ значение ${obj[key]}`);\r\n }\r\n//перебрать прям всё всё\r\nfunction getFromObj(item, str = '-') {\r\n    for (let key in item) {\r\n        if (typeof (item[key]) == 'object') {\r\n            console.log(`${str} Object: ${key}`);\r\n            getFromObj(item[key], str + '-');\r\n        } else {\r\n            console.log(`${str} Свойство: ${key} \\ значение ${item[key]}`);\r\n        }\r\n    }\r\n}\r\ngetFromObj(obj);\r\n","description":"Всё что есть в JavaScript'e основано на объектах. Каждый тип данных, классы, функции конструкторы. \r\nОбъекты объявляются фигурными скобками { };\r\nВ объекте присутствуют ключ и значение: key: \"value\"; (в основном так)\r\n\r\nТак же есть массивы и псевдомассивы. \r\nМассивы - ну это ясно что, не хочу объяснять, они во всех ЯП одинаковые. Объявляются квадратными скобками []. \r\nВ массиве присутствуют значения: ['value1', 'value2']; (в основном так)\r\n\r\nПсевдомассивы это объекты похожие на массивы, но имеющие внутри себя свойство length а так же он наследует прототипирование __proto__ \r\n\r\n\r\nОбъекты могут хранить в себе другие объекты, разные типы данных и методы.\r\nМассивы могут хранить в себе разные типы данных.","path":"Объекты и массивы"}},{"title":"Циклы и переборы","data":{"code":"\r\n//цикл с предусловием\r\nlet i = 0;\r\nwhile (i < 2) {\r\n    i++;\r\n   console.log(i); \r\n}\r\n\r\n//цикл с постусловием\r\nlet i = 0;\r\ndo {\r\n  console.log(i);\r\n} while(i < 2);\r\n\r\n//цикл с заданным количеством повторений\r\nfor(let i = 0; i < 2; i++) {\r\n  console.log(i);\r\n}\r\n\r\n//перебор\r\nconst arrTest = [1, 2, 3, 4];\r\n\r\narrTest.forEach(function (item, key, arr) { //элемент, ключ (итератор), массив\r\n    console.log(`${key}/${item}/${arr}`);\r\n});\r\n\r\n\r\n'use scrict';\r\n\r\n\r\n\r\n//>>>>>>>>>>>>>filter\r\n//Фильтрация массивов методом перебора filter\r\n//Filter возвращает новый массив\r\nconst names = [\r\n    'Ivan',\r\n    'Alex',\r\n    'Alexander',\r\n    'Ann'\r\n];\r\nconst shortNames = names.filter(item => {\r\n    return item.length < 5; //если длина каждого итема меньше 5\r\n});\r\nconsole.log(shortNames);\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n//>>>>>>>>>>>>> map\r\n//Перебрать массив и  изменить каждый элемент внутри, и вернуть новый изменённый масив\r\nconst answers = [\r\n    'IvAn',\r\n    'ANna',\r\n    'HeLLo'\r\n];\r\n\r\nconst resultAnswers = answers.map(item => item.toLowerCase()); //опять жэ, если 1 парамтер и 1 действие в функции, то можно сделать так\r\n//Аналог:\r\n/*\r\n    (item) => {\r\n        return item.toLowerCase();\r\n    }\r\n*/\r\nconsole.log(resultAnswers);\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n//>>>>>>>>>>>>> every/some\r\n//Функции перебора массива, проверка на совпадение, если какой то из элементов будет совпадать с some - вернётся true \r\n//С every наоборот, он проверят все значения на совпадение, и если какой то элемент не совпадает у условием вернётся  false\r\nconst someArray = [\r\n    4,\r\n    'asd',\r\n    'dsq'\r\n];\r\n\r\nconsole.log(someArray.some(item => typeof (item) === 'number')); //есть ли число в массиве (true)\r\n\r\nconst everyArray = [\r\n    4,\r\n    'asd',\r\n    'dsq'\r\n];\r\nconsole.log(someArray.every(item => typeof (item) === 'number')); //все ли числа в массиве? нет (false)\r\n\r\n\r\n\r\n\r\n\r\n//>>>>>>>>>>>>> reduce\r\n//Собрать массив в единное целое\r\n\r\n//у reduce 2 аргумента функции, 1 аргумент - сумма (резулбтат крч, то что будет return) предыдущего итератора перебора, 2 аргумент - текущий итем перебора\r\n//изначально sum = 0\r\n//Так же у reduce есть 3й агрумент, который присваивает начальное состояние для sum \r\nconst reduceArray = [\r\n    4,\r\n    5,\r\n    3,\r\n    2,\r\n    1\r\n];\r\n\r\nconsole.log(reduceArray.reduce((sum, current) => sum + current));\r\n\r\n//вариант со строками\r\nconst reduceArray2 = [\r\n    'Apple',\r\n    'Samsung',\r\n    'Xiaomi'\r\n];\r\nconsole.log(reduceArray2.reduce((sum, item) => `${sum}, ${item}`));\r\n\r\n\r\n\r\n\r\n\r\n//Example\r\n\r\nconst obj = {\r\n    ivan: 'persone',\r\n    ann: 'persone',\r\n    dog: 'animal',\r\n    cat: 'animal'\r\n};\r\n\r\n\r\nconst newArray = Object.entries(obj)\r\n    .filter(item => item[1] === 'persone')\r\n    .map(item => item[0]);\r\nconsole.log(newArray); //ivan, ann","description":"Циклы неотъемлемая часть любого ЯП. Конструкция циклов в JavaScript схожа со всеми остальными Си подобными языками. \r\nИмеются те же 3 основных вида циклов: цикл с предусловием, цикл с постусловием, цикл с заданным количеством повторений.\r\n\r\nПереборы это такой метод, который перебирает все данные внутри массивов. Он останавливается только когда данные будут все обработаны. Вызывается через forEach","path":"Циклы и переборы"}},{"title":"Раздновидности функций + ES6","data":{"code":"Код вверху","description":"Функции это отдельный участок кода, который можно вызвать и выполнять в любой момент, в любом месте (почти). Я даже не знаю зачем пишу дескрипшн по функциям. И так ясно, но ладно.\r\n\r\nВ JavaScript можно объявить несколько видов функций. \r\n\r\nОбычная функция (function declaration)\r\nСоздаётся как function nameFunction(arg) { }\r\nДанная функция доступна сразу после инициализации кода. И вызвать её можно до её объявления.\r\n\r\nОбъявленная функция (function expression)\r\nСоздаётся как const myFunc = function (arg) { }\r\nЭту функцию можно вызвать только после её создания.\r\n\r\nСтрелочная функция ES6\r\nне имеет контекста this (в данном случае)\r\nconst testFunc = (a) => console.log(a);\r\n\r\n\r\n","path":"Раздновидности функций + ES6"}},{"title":"Работа со строками string","data":{"code":"const fromServer = \"Один,Два,Три,Четыре\";\r\nconst parseToArr = fromServer.split(','); //разделить по , в массив\r\nparseToArr.sort(); //сортировать по алфавиту (только str)\r\nconsole.log(parseToArr);\r\nconst toString = parseToArr.join(';'); //соединить через ; (обратно из массива в str)\r\nconsole.log(toString);\r\n\r\nconst str = \"Hello world\";\r\nconsole.log(str.length); //свойство (длина строки)\r\nconsole.log(str.toUpperCase()); //функция (все большие буквы)\r\nconsole.log(str.indexOf(\"world\")); //функция (получить индекс начала совпадения строки)\r\nconsole.log(str.slice(str.indexOf(\"world\"), str.length)); //функция, взять из строки с индекса по индекс \r\nconsole.log(str.substring(str.indexOf(\"world\"), str.length)); //функция, взять из строки с индекса по индекс (то же самое только без отрицательных значений)\r\nconsole.log(str.substr(str.indexOf(\"world\"), 5)); //функция, взять из строки с индекса, длину","description":"Такая же неотъемлемая часть любого ЯП. Описывать не вижу смысла. Но методы опишу ниже в коде.","path":"Работа со строками string"}},{"title":"Логические операторы","data":{"code":"//кода нет","description":"•\tКакое будет выведено значение: let x = 5; alert( x++ ); ?\r\n•\t5\r\n\r\n•\tЧему равно такое выражение: [ ] + false - null + true ?\r\n•\tNaN\r\n\r\n\r\n•\tЧто выведет этот код: let y = 1; let x = y = 2; alert(x); ?\r\n•\t2\r\n\r\n\r\n•\tЧему равна сумма [ ] + 1 + 2?\r\n•\t12\r\n\r\n\r\n•\tЧто выведет этот код: alert( \"1\"[0] )?\r\n•\t1\r\n\r\n\r\n•\tЧему равно 2 && 1 && null && 0 && undefined ?\r\n1.\t&& - запинается на лжи (false)\r\n2.\t(2 – true && 1 – true) - true, пошли дальше вернули 1\r\n3.\t(1 – true && Null - false), Запнулись на false\r\n4.\tNull – false, запнулись, вернули null\r\n\r\n\r\n\r\n•\tЕсть ли разница между выражениями? !!( a && b ) и (a && b)?\r\n•\tСлева bool а справа number – не равны \r\n\r\n\r\n•\tЧто выведет этот код: alert( null || 2 && 3 || 4 ); ?\r\n1.\t&& - запинается на лжи (false) \r\n1.1\tlet a = 5;\r\nlet b = 3;\r\n(a && b) будет return b; //у оба нас true,  вернул последнее значение b\r\n\r\nlet a = null;\r\nlet b = 3;\r\n(a && b) будет return a; //у нас первое false, запнулись на нём, вернули a\r\n\r\n2.\t|| - запинается на правде (true) \r\n2.1\tlet a = 5;\r\nlet b = 3;\r\n(a || b) будет return a; //у нас первое true, вернул a\r\n\r\nlet a = null;\r\nlet b = 3;\r\n(a || b) будет return b; //у нас второе true, вернул b\r\n3.\tСначала сравниваем null || 2 – первое false не запнулись, второе true запнулись вернули 2\r\n\r\n4.\tПотом сравниваем 2 && 3 – у нас оба true, мы не запнулись и вернули 3\r\n5.\tПотом сравниваем 3 || 4 – первое true, значит запнулись, выводим 3\r\n6.\tИтого наш alert выведет 3\r\nP.S: null - false, undefined - false, 0 – false, NaN – false, “” - false; всё остальное true, [] – true, {} – true, 1 – true, “a” - true\r\n\r\n\r\n•\ta = [1, 2, 3]; b = [1, 2, 3]; Правда ли что a == b ?\r\n•\tfalse\r\n\r\n•\tЧто выведет этот код: alert( +\"Infinity\" ); ?\r\n•\tЕго и выведет number Infinity\r\n\r\n•\tВерно ли сравнение: \"Ёжик\" > \"яблоко\"?\r\n•\tFalse, по юникоду надо смотреть \r\n\r\n\r\n•\tЧему равно 0 || \"\" || 2 || undefined || true || falsе ?\r\n\r\n1.\tТ.к. у нас || запинается на true\r\n2.\t0 = false – не запнулись пошли дальше\r\n3.\t“” = false – не запнулись пошли дальше\r\n4.\t2 =  true, запнулись вернули 2\r\n","path":"Логические операторы"}},{"title":"Преобразование типов данных","data":{"code":"const testMath = \"12.2px\";\r\nconsole.log(parseInt(testMath)); //перевод str в int\r\nconsole.log(parseFloat(testMath)); //перевод str в float\r\n\r\nconst num = 12.3;\r\nconsole.log(Math.round(num)); //округление числа (тоже лишним не будет здесь)\r\n","description":"Конвертирование из одного типа данных в другой. Нужно для того что бы адекватно выполнять допустим математические операции. Т.к. все поля которые отправляет пользователь всегда в string.","path":"Преобразование типов данных"}},{"title":"Прототипирование","data":{"code":"const soldier = {\r\n    health: 100,\r\n    armor: 100,\r\n    sayHello: function () {\r\n        console.log('Hello');\r\n    }\r\n};\r\n\r\nconst john = {\r\n    health: 100\r\n};\r\n\r\n//устаревший формат наследования:\r\njohn.__proto__ = soldier;  //прототип джона - солдат, унаследовали так сказать\r\nconsole.log(john.armor); //взяли из родительского свойство \r\njohn.sayHello();\r\n//новый формат который лучше использовать\r\nconst ivan = {\r\n    health: 50\r\n};\r\n\r\nObject.setPrototypeOf(ivan, soldier); //привязать прототип soldier к ivan (когда объект ivan уже создан)\r\nivan.sayHello();\r\n\r\nconst andrey = Object.create(soldier); //создать объект наследуя прототип soldier\r\nivan.sayHello();","description":"ООП (но тут прототипно-ориентированый язык по сути, всё что есть в js - переменные, массивы, функции, все наследуются от __proto__ прототип)\r\n (конечная точка наследований прототипов всех массивов,переменных,функций это  объект Object)\r\nПоэтому JS это не прям по сути ООП, а ПОП прототипно ориентированное программирование","path":"Прототипирование"}},{"title":"Работа с элементами на странице","data":{"code":"'use strict';\r\n\r\n//старый вид селекта элементов (тут нет forEach)\r\n//HtmlCollection\r\nconst box = document.getElementById('box');\r\nconst buttons = document.getElementsByTagName('button');\r\nconst circles = document.getElementsByClassName('circle');\r\n//новый вид селектора элементов (тут есть forEach)\r\n//NodeList\r\n//Получает псевдомассив\r\nconst boxNew = document.querySelectorAll('#box');\r\nconst buttonsNew = document.querySelectorAll('button');\r\nconst hearts = document.querySelectorAll('.heart');\r\n//Получить только первый элемент\r\n//Возвращает сразу первый попавшийся элемент\r\nconst circleOne = document.querySelector('.circle');\r\n\r\n// box.style.background = 'blue';\r\nbox.style.width = '500px';\r\nbuttons[1].style.borderRadius = '100%';\r\ncircles[0].style.background = 'red';\r\nbox.style.cssText = \"background: blue; height: 300px; width: 100px\";\r\n\r\n\r\nfor(let i = 0; i < buttons.length; i++) {\r\n    buttons[i].style.cssText = \"background-color: yellow; color: black;\";\r\n}\r\n\r\nhearts.forEach(item => {\r\n    item.style.background = \"blue\";\r\n});\r\n\r\nconst text = document.createTextNode('Привет мир');\r\n\r\nconst div = document.createElement('div');\r\ndiv.classList.add('black');\r\ndocument.body.append(div);\r\n// document.querySelector('.wrapper').append(div); //вставить в конец блока\r\n// document.querySelector('.wrapper').prepend(div); //вставить в начало блока\r\n// hearts[0].before(div); //добавить перед этим элементом\r\n// hearts[0].after(div); //добавить после этим элементом\r\n// circles[0].remove(); //удалить элемент\r\n// hearts[0].replaceWith(circles[0]); //заменить собой каким то элементом\r\n\r\n//Устаревшие команды\r\n// document.body.appendChild(div);\r\n// document.querySelector('.wrapper').insertBefore(div, hearts[1]); //вставить в начало блока после какого-то\r\n// document.querySelector('.wrapper').removeChild(hearts[2]); //удалить какой то элемент у родителя (нельзя удалить сразу тот элемент)\r\n// document.querySelector('.wrapper').replaceChild(div, hearts[1]); //заменить какой то элемент на какой то у родителя (нельзя заменить сразу элемент)\r\n//Всё дальше норм\r\ndiv.innerHTML = \"<h1>Hello</h1>\"; //вставить что то внутрь HTML\r\n// div.textContent = \"<h1>Hello world</h1>\"; //вставить только как текст\r\n\r\n//beforebegin - перед началом элемента (перед открыважщим тегом)\r\n//afterbegin - после начала элемента (внутри элемента, перед всеми его дочерними)\r\n//afterend - после конца элемента (после закрывающего тега)\r\n//beforeend - перед концом элемента (внутри элемента, перед закрывающим тегом)\r\ndiv.insertAdjacentHTML('beforeend', '<h1>world</h1>'); //вставить (перед, после,  в) элементе\r\n\r\n\r\n","description":"Самая важная часть JavaScript это работа с элементами. Мы должны уметь найти элемент, изменять его свойства. Цепляться к событиям разным. И очень много всего. Тут мы затронем только несколько возможностей. А именно: поиск элемента в html, изменение inline css стилей элемента, вставка html до, после или перед элементом. Код ниже, всё описано.","path":"Работа с элементами на странице"}},{"title":"События Events","data":{"code":"'use strict';\r\n\r\nconst\r\n    btn = document.querySelector('#btn'),\r\n    overlay = document.querySelector('.overlay'),\r\n    link = document.querySelector('a');\r\n\r\n//устаревший формат, лучше не юзать\r\n//нельзя добавить ещё одно событие\r\n//нельзя удалить событие\r\n btn.onclick = function () {\r\n     alert('asd');\r\n };\r\n\r\n//правильный вариант\r\n//события выполняются только в порядке очереди\r\n//можно добавлять кучу функций на одно событие\r\n//можно удалять события\r\n btn.addEventListener('click', () => {\r\n     alert('dsa');\r\n });\r\n\r\n btn.addEventListener('click', () => {\r\n     alert('ads');\r\n });\r\nlet i = 0;\r\nconst deleteElement = function(e) {\r\n    console.log(e.target); //получает конечный элемент события (вложенный)\r\n    console.log(e.currentTarget); //получает тот элемент, на котором было событие\r\n    console.log(e.type);\r\n    i++;\r\n     if (i == 1) {\r\n         btn.removeEventListener('click', deleteElement);\r\n     }\r\n};\r\nbtn.addEventListener('click', deleteElement, {\r\n    once: true //выполнить всего 1 раз\r\n});\r\noverlay.addEventListener('click', deleteElement);\r\n\r\n\r\nlink.addEventListener('click', (e) => {\r\n    e.preventDefault();\r\n    console.log(e.target);\r\n});","description":"События это участки кода, которые вызываются во время определённых действий на странице. Допустим пользователь нажал на кнопку, это событие будет click, и мы средствами JS подцепляемся к этому событию, и выполняем необходимые действия.","path":"События Events"}},{"title":"Элементы (Elements) и Ноды (Nodes)","data":{"code":"console.log(document.body);\r\nconsole.log(document.head);\r\nconsole.log(document.documentElement);\r\nconsole.log(document.body.childNodes); //полчить всех наследников (Узлы/ноды) от родителя body (включая перенос строк text) в виде псевдомассива\r\nconsole.log(document.body.firstChild); //получить первого наследника (Узлы/ноды) внутри родителя (включая перенос строк)\r\nconsole.log(document.body.lastChild); //получить последнего наследника (Узлы/ноды) внутри родителя (включая перенос строк)\r\nconsole.log(document.querySelector('#current').parentNode); //получить родителя\r\nconsole.log(document.querySelector('#current').parentNode.parentNode); //получить родителя родителя (включая перенос строк)\r\nconsole.log(document.querySelector('li[data-current=\"3\"]').nextSibling); //получить следующий узел (включая перенос строк)\r\nconsole.log(document.querySelector('li[data-current=\"3\"]').previousSibling); //получить предыдущий узел (включая перенос строк)\r\n\r\n//получить только элемент, не узел\r\nconsole.log(document.querySelector('li[data-current=\"3\"]').nextElementSibling); //получить следующий элемент\r\nconsole.log(document.querySelector('li[data-current=\"3\"]').previousElementSibling); //получить предыдущий элемент\r\nconsole.log(document.querySelector('#current').parentElement); //получить родителя\r\nconsole.log(document.querySelector('#current').parentElement.parentElement); //получить родителя родителя\r\nconsole.log(document.body.firstElementChild); //получить первого наследника внутри родителя (Элемент)\r\nconsole.log(document.body.lastElementChild); //получить последнего наследникавнутри родителя (Элемент)\r\n\r\n//получить всех наследников за исключением узлов текстовых (включая перенос строк)\r\nfor (let node of document.body.childNodes) {\r\n    if (node.nodeName == \"#text\") continue;\r\n    console.log(node);\r\n\r\n}","description":"В JS есть чёткая грань между элементами и нодами HTML документа. \r\nВо время селекта нод, в них входят узлы. Узлы это текст, элемент, перенос строки, комментарии.\r\nА элемент это тупо HTML элемент со своими методами.","path":"Элементы (Elements) и Ноды (Nodes)"}},{"title":"Работа с классами элемента","data":{"code":"'use strict';\r\n\r\nconst btns = document.querySelectorAll('button');\r\n console.log(btns[0].classList.length); //количество классов у элемента\r\n console.log(btns[0].classList.item(0)); //получить класс из списка в виде строки\r\n btns[0].classList.add('red'); //добавить класс элементу (можно через запятую кучу)\r\n btns[0].classList.remove('blue'); //удалить класс у элемента (можно через запятую кучу)\r\n btns[0].classList.toggle('blue'); //тоглер класса (знаешь что это)\r\n\r\n if(btns[0].classList.contains('red')) { //проверка на существование класса, возвращает true \r\n     console.log('У кнопки есть класс RED');\r\n }\r\n\r\nbtns[0].addEventListener('click', () => {\r\n    if(btns[1].classList.contains('red')) {\r\n        btns[1].classList.remove('red');\r\n    } else {\r\n        btns[1].classList.add('red');\r\n    }\r\n    //аналогично\r\n    // btns[1].classList.remove('red');\r\n});\r\n\r\n//устаревшее\r\n console.log(btns[0].className); //возвращает как строку всегда (лучше не юзать)\r\n\r\n//делеширование событий (нескольким элементам задать одно действие на событие. Т.е. выдать общему родителю клик а потом от него отталкиваться)\r\n//делегирование событий родителя на его потомка\r\ndocument.querySelector('#first').addEventListener('click', (e) => {\r\n     console.log(e.target);\r\n     console.log(targetElement.tagName)\r\n     console.log(e.target.matches('button'));\r\n    if(e.target && e.target.matches('button')) { //ищет совпадение в элементе, если будет то вернёт true (можно button.red button#firstBtn и т.п.)\r\n    // if(e.target && e.target.tagName == 'BUTTON') {\r\n        console.log('Кликнули на кнопку родителя div');\r\n    }\r\n    \r\n});\r\n","description":"Описания не будет. Сразу в код.","path":"Работа с классами"}},{"title":"Таймеры","data":{"code":"'use strict';\r\n\r\nconst btn = document.querySelector('.btn');\r\n\r\nfunction anime() {\r\n    const el = document.querySelector('.box');\r\n    let pos = 0;\r\n    const id = setInterval(frame, 10);\r\n\r\n    function frame() {\r\n        if(pos == 300) {\r\n            clearInterval(id);\r\n        } else {\r\n            pos++;\r\n            el.style.top = pos+\"px\";\r\n            el.style.left = pos+\"px\";\r\n        }\r\n    }\r\n}\r\n\r\nbtn.addEventListener('click', (e) => {\r\n    e.preventDefault();\r\n    anime();\r\n});\r\n\r\n////////////////////////////////////\r\n let timerId2,\r\n    i = 0;\r\n\r\n btn.addEventListener('click', (e) => {\r\n     e.preventDefault();\r\n     // const timerId2 = setTimeout(logger, 2000);\r\n     timerId2 = setInterval(logger, 2000);\r\n });\r\n\r\n\r\nconst timerId = setTimeout((text) => {\r\n    console.log(text);\r\n }, 2000, 'Hello');\r\n\r\n\r\n function logger() {\r\n     console.log('Text');\r\n     i++;\r\n    if(i == 3) {\r\n        clearInterval(timerId2);\r\n    }\r\n }\r\n","description":"setTimeOut - выполняется 1 раз и всё\r\nsetTinterval - выполняется всегда пока его не очистишь clearInterval\r\n\r\nsetInterval не учитывает время выполнения кода функции, и при большом тайминге функции, интервал запустит следующий итератор \r\nsetTimeOut ожидает выполнения функции, после чего отсчитывает опять заданное количество МС и выполняет дальше \r\n\r\nлучше всего использовать рекурсивный setTimeOut (который вызывает сам себя изнутри) чем setInterval\r\n// let id = setTimeout(function log() {\r\n//     console.log('World');\r\n//     id = setTimeout(log, 500);\r\n// }, 500);","path":"Таймеры"}},{"title":"Работа с датами Date","data":{"code":"'use strict';\r\n\r\n\r\nconst now = new Date();\r\n\r\n//Геттеры\r\nconsole.log(now.getFullYear()); //получить год\r\nconsole.log(now.getMonth()); //получить месяц (0 - январь, 1 - февраль и т.п.)\r\nconsole.log(now.getDate()); //получить день (как обычно с 1)\r\nconsole.log(now.getDay()); //получить номер дня недели (воскресенье 0 день, суббота 6 день)\r\n//с часовыми поясами\r\nconsole.log(now.getUTCHours()); //получает местное время и по гринвичу\r\nconsole.log(now.getTimezoneOffset()); //получить разницу во времени между местным и гринвичем\r\nconsole.log(now.getTime()); //получить unix'time миллисекунд (от 1 января 1970)\r\n\r\n//Сеттеры\r\nnew Date.parse('2021-01-05'); // парсинг даты\r\nconsole.log(now.setHours(18)); //перевести время на 18:00 где 00 будет текущие минуты\r\nconsole.log(now);\r\n\r\n//Пример бенчмарка по времени выполнения\r\nlet start = new Date();//текущая дата до операций\r\nfor(let i = 0; i < 100000; i++) {\r\n    let some = i ** 3; //ввести в степень каждый раз (стандарт ES7 **)\r\n}\r\nlet end = new Date();//конечная дата после операций\r\nalert(`Цикл отработал за ${end - start} мс`); //разница между датами (всё по unix'time кэп)\r\n\r\n\r\n//Пример обратного отсчёта таймеры+дата (сколько осталось до конца акции)\r\n    //Timer\r\n    const deadline = '2021-01-07';\r\n\r\n    function getTimeRemaining(endtime){\r\n        const t = Date.parse(endtime) - Date.parse(new Date()),\r\n                days = Math.floor(t / (1000 * 60 * 60 * 24)),\r\n                hours = Math.floor((t / (1000 * 60 * 60)) % 24),\r\n                minutes = Math.floor((t / 1000 / 60) % 60),\r\n                seconds =  Math.floor((t / 1000) % 60);\r\n        return {\r\n            'total': t,\r\n            'days': days,\r\n            'hours': hours,\r\n            'minutes': minutes,\r\n            'seconds': seconds\r\n        };\r\n    }\r\n\r\n    function getZero(number) {\r\n        if(number >= 0 && number < 10) {\r\n            return `0${number}`;\r\n        }\r\n        return number;\r\n    }\r\n\r\n    function setClock(selector, endtime) {\r\n        const timer = document.querySelector(selector),\r\n                days = timer.querySelector('#days'),\r\n                hours = timer.querySelector('#hours'),\r\n                minutes = timer.querySelector('#minutes'),\r\n                seconds = timer.querySelector('#seconds'),\r\n                timerInterval = setInterval(updateClock, 1000);\r\n        function updateClock() {\r\n            const t = getTimeRemaining(endtime);\r\n            days.innerHTML = getZero(t.days);\r\n            hours.innerHTML = getZero(t.hours);\r\n            minutes.innerHTML = getZero(t.minutes);\r\n            seconds.innerHTML = getZero(t.seconds);\r\n            if(t.total <= 0) {\r\n                clearInterval(timerInterval);\r\n            }\r\n        }\r\n        updateClock();\r\n    }\r\n    setClock('.timer', deadline);","description":"Описание даже не знаю что. Позже напишу.","path":"Работа с датами Date"}},{"title":"Функции конструкторы","data":{"code":"function User(name, id) {\r\n    this.name = name;\r\n    this.id = id;\r\n    this.human = true;\r\n    this.hello = () => {\r\n        console.log(`Hello ${this.name}`);\r\n    };\r\n}\r\n\r\nUser.prototype.exit = function () { //расширяем функционал конструктора\r\n    console.log(`${this.name} вышел`);\r\n};\r\n\r\nconst ivan = new User('Иван', 22);\r\nconst alex = new User('Alex', 25);\r\n\r\nivan.hello();\r\nalex.hello();\r\n\r\nivan.exit();\r\nalex.exit();\r\n\r\nconsole.log(ivan);\r\nconsole.log(alex);\r\n","description":"    Функции конструкторы  это объекты которые могут хнарить в себе прототипные данные и функции\r\n    Это сделано для того что бы можно было создавать множество однотипных объектов но с разными свойствами\r\n    Общее правило в создании функций конструкторов то что он начинается с заглавной буквы\r\n    Создание нового объекта функции конструктора выполняется через new\r\n    К каждому элементу функции конструатора обращение идёт через this\r\n    В функциях конструкторах можно добавить новые прототипные данные и функции через .prototype.foo = bar;\r\n    Функции конструкторы это стандарт ES5\r\n    В ES6 добавили сахар для этого, под видом обычного ООП class ","path":"Функции конструкторы"}},{"title":"Контекст this","data":{"code":"'use strict';\r\n\r\n\r\n// в обычной функции классической function() this == window\r\n// при использовании 'use strict' this == undefined \r\n\r\n\r\nfunction showThis(a,b) {\r\n    console.log(this); //== undefined\r\n    function sum() {\r\n        console.log(this); //== undefined\r\n        return this.a + this.b; // undefined + undefined == error\r\n    }\r\n\r\n    console.log(sum());\r\n}\r\nshowThis(4,5);\r\n\r\n\r\n//если используется метод внутри объекта, контекст this ссылается на сам объект\r\nconst obj = {\r\n    a: 20,\r\n    b: 15,\r\n    sum: function() {\r\n        console.log(this);\r\n        function shout() { //будет undefined т.к. это уже не метод а обычная функция (не стрелочная)\r\n            console.log(this);\r\n        }\r\n    }\r\n};\r\nobj.sum();\r\n\r\n\r\n// //this в конструкторах и классах это новый экземпляр объекта \r\nfunction User(name, id) {\r\n    //фактически this = {} \r\n    //далее в этот объект добавляются свойства и методы \r\n    this.name = name;\r\n    this.id = id;\r\n    this.human = true;\r\n    //return this;\r\n}\r\n\r\n// const ivan = new User('Иван', 22);\r\n\r\n\r\n//ручная привязка this через apply и call\r\n//контекст this можно передать в функцию, через методы apply и call\r\n//функции абсолютно одинаковые\r\n//в параметрах функции передаём объект для контекста\r\n//можно сказать что это sayName где инициализируется user\r\nfunction sayName(surname) {\r\n    console.log(this);\r\n    console.log(this.name + ' '+ surname);\r\n}\r\n\r\nconst user = {\r\n    name: 'John'\r\n};\r\n\r\nsayName.call(user, 'Test'); //передача контекста this (передача аргументов функции передаются через запятую)\r\nsayName.apply(user, ['Testo']); //передача контекста this (а тут передача аргументов в виде массива)\r\n\r\n\r\n//ручная привязка this через bind\r\n//контекст this так же можно передать через создание новой функции средствами bind\r\n//double это новая функция к которой привязан контекст this\r\n//где мы в контекст присвоили 2\r\n//далее вызываем новую функцию double где передаём аргумент функции, т.к. контекст this у нас 2, то 2*3 = 6\r\nfunction count(num) {\r\n    return this * num;\r\n}\r\nconst double = count.bind(2);\r\nconsole.log(double(3));\r\n\r\n\r\nconst btn = document.querySelector('button');\r\n\r\nbtn.addEventListener('click', function () { //если объявление обработчика событий в классическом стиле function() { }\r\n    console.log(this); //конекст является сам элемент \r\n    //проще this == event.target;\r\n});\r\n\r\n//стрелочная же функция не передаёт контекст this\r\n//она наследует this от своего родителя\r\nconst obj2 = {\r\n    num: 5,\r\n    sayNubmer: function() { //метот ссылается на объект в котором он существует\r\n        const say = () => {\r\n            console.log(this); //в нашем случае контекст вернёт родителя sayNumber т.к. это стрелочная функция\r\n        }\r\n        say();\r\n    }\r\n}\r\n\r\nobj2.sayNubmer();\r\n\r\n\r\n\r\nbtn.addEventListener('click', () => { //если объявление обработчика событий в стрелочном стиле \r\n    console.log(this); //конекст является window (родитель кнопки window)\r\n});\r\n\r\n","description":"Как у старших ЯП есть this. Которая обращается к текущему экземпляру объекта. Все примеры ниже в коде","path":"Контекст this"}},{"title":"Классы Class ES6","data":{"code":"//название класса всегда с заглавной буквы\r\nclass Rectangle {\r\n    constructor(height, width) {\r\n        this.height = height;\r\n        this.width = width;\r\n    }\r\n\r\n    calcArea() {\r\n        return this.height * this.width;\r\n    }\r\n}\r\n\r\nconst recCalc = new Rectangle(20, 30);\r\nconst recCalc2 = new Rectangle(40, 40);\r\nconsole.log(recCalc.calcArea());\r\nconsole.log(recCalc2.calcArea());\r\n\r\n//Наследование\r\nclass ColoredRectangleWithText extends Rectangle {\r\n    constructor(height, width, color, text) {\r\n        super(height, width); //вызывает конструктор родителя (в нашем случае Rectangle) всегда первой строчкой\r\n        this.color = color;\r\n        this.text = text;\r\n    }\r\n\r\n    showProps() {\r\n        return `${this.text}; ${this.color}`;\r\n    }\r\n}\r\n\r\nconst coloredRectangle = new ColoredRectangleWithText(100, 100, 'red', 'Example');\r\n\r\nconsole.log(coloredRectangle.showProps());\r\nconsole.log(coloredRectangle.calcArea());\r\n\r\n//Инкапсуляция (оказывается не работает)\r\nclass MyNewClass {\r\n    constructor(text) {\r\n        this._text = text; //свойство _text небудет доступно извне\r\n    }\r\n\r\n    getText() {\r\n        return this._text;\r\n    }\r\n}\r\n\r\nconst newClass = new MyNewClass('Hello world');\r\nconsole.log(newClass._text);\r\nconsole.log(newClass.getText());\r\n\r\n//полиморфизм (переопределение на свои методы, перезапись родительских)\r\nclass Person {\r\n    constructor(name) {\r\n        this.name = name;\r\n    }\r\n    me() {\r\n        return `My name is ${this.name}`; \r\n    }\r\n}\r\nconst axel = new Person('Axel');\r\nconsole.log(axel.me());\r\nclass Employee extends Person {\r\n    constructor(name, salary) {\r\n        super(name);\r\n        this.salary = salary;\r\n    }\r\n    me() {  //вот тут полиморфизм, мы перезаписали метод родителя, но доступны свойства родителя\r\n        return `My name is ${this.name} and my salary is ${this.salary}`;\r\n    }\r\n}\r\nconst nick = new Employee('Nick', 3000);\r\nconsole.log(nick.me());","description":"Классы появились с ES6\r\nКлассы это те же функции конструкторы, только в красивой обёртке (сахар)","path":"Классы Class ES6"}},{"title":"Rest оператор","data":{"code":"  class CardItem {\r\n        constructor(src, alt, subtitle, descriprion, price, parentElement, ...classes) { //Rest оператор у нас ...classes \r\n            this.src = src;\r\n            this.subtitle = subtitle;\r\n            this.descriprion = descriprion;\r\n            this.price = price;\r\n            this.alt = alt;\r\n            this.transfer = 27; // актуальный курс доллара \r\n            this.classes = classes;\r\n            this.changeToUAH();\r\n            this.parentElement = document.querySelector(parentElement);\r\n        }\r\n\r\n        changeToUAH() { //конвертация доляров в гривны по курсу\r\n            this.price = this.price * this.transfer;\r\n        }\r\n\r\n        render() {\r\n            const divElement = document.createElement('div');\r\n            if(this.classes.length) { //если не указали никакой аргумен в rest, будет пустой массив, поэтому проверяем на длинну массива\r\n                this.classes.forEach(className => divElement.classList.add(className)); // перебрали rest и добавили все классы в div \r\n            } else {\r\n                divElement.classList.add('menu__item');\r\n            }\r\n            divElement.innerHTML = `тут html встака должна быть со свойствами класса this`;\r\n            this.parentElement.append(divElement);\r\n        }\r\n\r\n\r\n    }\r\n\r\n    new CardItem(\r\n        \"img/tabs/vegy.jpg\",\r\n        `vegy`,\r\n        `Меню \"Фитнес\"`,\r\n        `Меню \"Фитнес\" - это новый подход к приготовлению блюд: больше свежих овощей и фруктов. \r\n                Продукт активных и здоровых людей. Это абсолютно новый продукт с оптимальной ценой и высоким качеством!`,\r\n        5,\r\n        '.menu .container'\r\n    ).render();\r\n\r\n    new CardItem(\r\n        \"img/tabs/elite.jpg\",\r\n        `elite`,\r\n        `Меню \"Премиум\"`,\r\n        `В меню “Премиум” мы используем не только красивый дизайн упаковки, но и качественное исполнение блюд. \r\n                Красная рыба, морепродукты, фрукты - ресторанное меню без похода в ресторан!`,\r\n        6,\r\n        '.menu .container',\r\n        //тут начинаются REST агрументы \r\n        'menu__item',\r\n        'two__class',\r\n        'tree__class'\r\n    ).render();","description":"Rest оператор это такой оператор который указывается в аргументе функции\r\nРаботает как ...spread только наоборот, собирает аргументы в массив (spread наоборот выбирает из массива в переменные)\r\nТакой оператор ставится в конце функции, и все аргументы после основных будут записаны в Rest\r\nАргументов REST можно писать хоть сколько т.к. это массив","path":"Rest оператор"}},{"title":"POST и GET через XMLHttpRequest ","data":{"code":"//POST запрос \r\n\r\n  const request = new XMLHttpRequest(); //создаём экземпляр класса\r\n            request.open('POST', 'server.php'); //выполняем настройки \r\n            // request.setRequestHeader('Content-type', 'multipart/form-data'); //заголовок от FormData заполняется автоматически если отправлять FormData, если хедеры использовать такие то будут пустые данные\r\n            request.setRequestHeader('Content-type', 'application/json'); //Если через JSON то надо выставлять такой тип контента (обязательно formData нужно парсить в JSON)\r\n            const Fdata = new FormData(form); //получаем данные с формы (любой)\r\n            const obj = {}; //объект\r\n\r\n            Fdata.forEach(function (value, key) { //через перебор из FormData получаем \r\n                obj[key] = value; //в объект\r\n            });\r\n\r\n            const json = JSON.stringify(obj); //парсим в JSON \r\n            request.send(json); //отправляем на бэкэнд JSON\r\n//в случае с FormData то можно просто request.send(Fdata); без setRequestHeader\r\n\r\n//проверка состояния запроса\r\n  request.addEventListener('load', (e) => { //подцепляем событие load\r\n                if (request.status === 200) { //если 200 ОК\r\n                    console.log(request.response); //тут наш ответ от бэкэнда\r\n                } else {\r\n                    //тут остальные ошибки\r\n                }\r\n            });\r\n\r\n//GET\r\nconst request = new XMLHttpRequest(); //такой же экземпляр класса\r\n\r\n    request.open('GET', 'current.json'); //собрать настройки для запроса\r\n    request.setRequestHeader('Content-type', 'application/json; charset=utf-8'); //настройка заголовков\r\n    request.send(); //отправка запроса\r\n\r\n    // request.addEventListener('readystatechange', () => { //статус запроса  (каждый раз будет обрабатываться при изменени состояния readyState, по readyState можно загуглить)\r\n    request.addEventListener('load', () => { //статус запроса \r\n        //request.readyState - проверка состояния запроса, их 4 (подробнее в гугле)\r\n        if(request.status == 200) { //readyState 4 done по запросу, request по status 200 OK\r\n            console.log(request.response); //ответ от бэкэнда\r\n        } else {\r\n          //ошибка\r\n        }\r\n    });","description":"В старых стандартах использовался AJAX запрос XMLHttpRequest. В данный момент его не используют. Но есть старые разработки, где он встречается. Поэтому его лучше знать.","path":"POST и GET через XMLHttpRequest "}},{"title":"Promise (Промисы)","data":{"code":"//Создание промиса выглядит так\r\n//resolve - это успешное выполнение кода\r\n//reject - неуспешное \r\nconst req = new Promise((resolve, reject) => {\r\n    setTimeout(() => { //симуляция запроса в бэкэнд\r\n        const product = {\r\n            name: 'Mouse',\r\n            order: 2000\r\n        };\r\n        console.log('Подготовка данных....');\r\n        resolve(product); //тут мы вызываем функцию успешного выполнения промиса\r\n        //в параметры выдаём то что нужно использовать дальше\r\n    }, 2000);\r\n});\r\n\r\nreq.then(data => { //сюда приходит дата из resolve(data);\r\n    //так же можно внутри промиса создать новый промис и отправить его через резолв\r\n    return new Promise((resolve, reject) => {\r\n        setTimeout(() => { //симуляция запроса в бэкэнд\r\n            data.status = 'ordered';\r\n            console.log('Модифицируем...');\r\n            reject(); //симулируем ошибку\r\n            // resolve(data);\r\n        }, 3000);\r\n    });\r\n}).then(data => { //т.к. у нас верху ретюрним промис с резолвом, то можем сразу вызвать резолв then\r\n    data.modify = true; //ещё раз модифицируем\r\n    return data; //возвращаем модифицированные данные (дальше резолвим)\r\n}).then(modifydata => { //так же дальше можем передать резолв следующей цепочке\r\n    console.log(modifydata);\r\n}).catch(() => { //если что то пошло нет так, то вызываем в любой цепочке reject и он сразу приходит в catch  (пропуская остальные цепочки)\r\n    console.error(`Ошибка данных`);\r\n}).finally(() => { //после всех цепочек и обработок ошибок будет выполняться всегда финальный каллбэк  (даже при catch reject)\r\n    console.log('Finally');\r\n    //тут какие либо манипуляции по очистке данных форм и т.п.\r\n});\r\n\r\n\r\nconst test = time => {\r\n    return new Promise(resolve => { //иногда можно обойтись без reject (очень редко)\r\n        setTimeout(() => {\r\n            resolve();\r\n        }, time); //запустить таймаут по time\r\n    });\r\n};\r\n\r\n// test(1000).then(() => {\r\n//     console.log('Резолв сработал 1000');\r\n// });\r\n// test(2000).then(() => {\r\n//     console.log('Резолв сработал 2000');\r\n// });\r\n\r\nPromise.all([test(1000), test(2000)]).then(() => { //запустить все промисы по очереди через .all и после всех выполнений сможем в resolve (.then)\r\n    console.log('Резолвы сработали');\r\n});\r\n\r\nPromise.race([test(1000), test(2000)]).then(() => { //запустить все промисы по очереди через .race и после первого выполнения будет resolve (.then) \r\n    console.log('Резолвы сработали');\r\n});\r\n\r\n\r\n//без комметов, просто пример повседневного промиса\r\nconst reqTest = new Promise((resolve, reject) => {\r\n    const product = {\r\n        name: 'Mouse',\r\n        order: 2000\r\n    };\r\n    if (product.order >= 2000) {\r\n        resolve(product);\r\n    } else {\r\n        reject();\r\n    }\r\n}).then(data => {\r\n    data.modify = true;\r\n    return data;\r\n}).then(mdata => {\r\n    mdata.mtest = false;\r\n    return mdata;\r\n}).then(test => {\r\n    console.log(test);\r\n}).catch(() => {\r\n    console.log('Error');\r\n}).finally(() => {\r\n    console.log('End');\r\n});","description":"Promise (промисы) нужны для последовательного выполнения асихронных операций\r\nт.к. от бэкэнда результат разных операций может приходить в разное время\r\nи нам необходимо что бы операции выполнялись последовательно (по цепочке)\r\n\r\n\r\nцепочка такая\r\nСоздаём промис new Promise в нём аргументы каллбэков resolve и reject\r\nresolve - это каллбэк успешного выполнения\r\nreject - не успешного\r\nКогда мы вызываем resolve() то дальшейшая цепочка выполнения каллбэчится к .then \r\nКогда какие либо ошибки, а так же reject будет каллбэчится к .catch ","path":"Promise (Промисы)"}},{"title":"Fetch","data":{"code":"  fetch('https://jsonplaceholder.typicode.com/posts', { //если не задавать объект с параметрами то будет просто GET\r\n        //объект параметров запроса \r\n        method: 'POST', //GET,POST,PUT,PATCH,DELETE\r\n        body: JSON.stringify({ //Данные отправляемые на сервер (в нашем случае JSON с данными)\r\n            name: 'Ras',\r\n            age: 25\r\n        }),\r\n        headers: { //заголовки запроса\r\n            'Content-type': 'application/json'\r\n        }\r\n    }) \r\n        .then(response => response.json()) //получили ответ и пропарсили черещ встроенный метод .json в fetch, который сразу продолжает промис (resolve)\r\n        .then(json => console.log(json)); //пропарсенный json выведем в консоль ","description":"Современная система отправки запросов и получения ответов от бэкэнда\r\nЗаменяет XMLHttpRequest, более гибок и может в промисы","path":"Fetch"}}]}]